
<!--
  $Id: wrspiceVersion.xml,v 1.78 2016/05/11 17:45:49 stevew Exp $

  Modified for use with WRspice, Whiteley Research Inc. (wrcad.com).
-->

<!--
  Initial import for admst (Verilog-AMS) translators for WRspice.
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0"
  xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- ---------------------------------------------------------------------- -->
<!--
  Global variables.  Variables with all-upper-case names are
  user-configurable.
-->

<!--
  The DDTFUNC variable controls how static/dynamic terms are handled.
  It can be set to one of three strings.

  'legacy'
  This is the original adms formulation.

  'onepass'
  This is a newer single-pass formulation, that (I think) handles
  higher-order time derivatives correctly.

  'twopass'
  NO LONGER SUPPORTED (3/27/2014)
  The multi-pass option has been dropped, since it is no longer in use
  and it seems pointless to maintain the code.  All dc/tran loading is
  now done in the *load.cc file, as was originally true.  The *p1.cc
  and *p2.cc files are gone.

  This loads the matrix in two steps, and rigorously separates
  static and dynamic terms, so that each is loaded correctly.

  One problem is that the original adms implicit code would
  categorize each contribution as static or dynamic, and would handle
  the entire contribution one way or the other.  A contribution is
  "dynamic" if a ddt call is found in the rhs.  This is of course
  wrong if the contribution rhs contains both types of terms.  The
  two-pass formulation gets around this, but at the cost of running
  the load function twice.

  In the two-pass case, ddt is handled more like a function, using
  the simulator to perform the operation.  On the first pass, the ddt
  function returns the current, and collapses the voltage derivatives
  to zero.  Only static loading methods are used, so the dynamic
  contributions are represented by rhs current sources only.  These
  are loaded into the rhs.

  On the second pass, the ddt function simply passes through the
  argument and all voltage derivatives.  We keep only the jacobian
  terms, summing into the JDVALs, but not loading the matrix as yet. 
  When finished, the JDVALs contain the sum of the static
  contribution (computed as a side effect) and the dynamic
  contributions.  We subtract off the static parts, which were saved
  in the JSVALs in pass 1, leaving only the actual dynamic
  contributions, which are properly loaded.

  The revised implicit code now contains an initial step that will
  atomize mixed contributions to individual "pure" contributions. 
  There is also a new test in the initialization code that will verify
  that each contribution is indeed pure.  Thus, there is presently no
  need for the two-pass formulation, however certain aspects were
  retained in the one-pass formulation that is the current default. 
  In particular, the sCKT::va_ddt function performs the actual
  differentiation.  This is called like a function, so that
  higher-order derivitaves can be computed.  The original adms
  approach would collapse terms with higher order derivatives into a
  first derivative expression, which is not correct.

  DDTFUNC  'legacy'   original adms
           'onepass'  one-pass, use simulator ddt
-->
  <admst:variable name="DDTFUNC" value="onepass"/>

<!-- End of user-configurable switches. -->

<!--
  The module short name, and upper-case and lower-case versions.
-->
  <admst:variable name="module"/>
  <admst:variable name="moduc"/>
  <admst:variable name="modlc"/>

<!--
  Set to 'yes' if an instance 'm' parameter was added.
-->
<admst:variable name="added_m" value="no"/>

<!--
  If we aren't told how to assign the parameters between model and
  instance, all parameters will be taken as instance parameters.  This
  variable is assigned to 'yes' in that case.  The model struct will
  contain shadows of all parameters, and the instance list.
-->
<admst:variable name="unified" value="no"/>

<!--
  When this variable is set, for parametertype='instance' variables,
  the emitted prefix is "model->".  This is set when unified='yes' and
  we are initializing the shadow model parameters, whose rhs may
  contain instance params that should be taken as model params.
-->
<admst:variable name="inst_to_model" value="no"/>

<!--
  These variables contain the SPICE model name for devices with p/n
  flavors, e.g., nmos and pmos.
-->
<admst:variable name="n_flavor" value=""/>
<admst:variable name="p_flavor" value=""/>

<!--
  If this model has p/n flavors (e.g., nmos and pmos), one or both of
  these variables will be defined to 'yes' if the model has a
  parameter with a name matching the SPICE model name.
-->
<admst:variable name="has_n_flavor" value="no"/>
<admst:variable name="has_p_flavor" value="no"/>

<!-- noise contribution lists -->
<admst:variable name="fnoise"/>
<admst:variable name="tnoise"/>
<admst:variable name="wnoise"/>
<admst:variable name="noinames"/>

<!-- probing returns -->
<admst:variable name="pprobe"/>
<admst:variable name="qprobe"/>
<admst:variable name="e"/>
<admst:variable name="ep"/>
<admst:variable name="eq"/>
<admst:variable name="epq"/>

<!-- flicker noise exponent return -->
<admst:variable name="fe"/>

<!-- set during contribution purity test -->
<admst:variable name="chk_purity" value="no"/>

<!-- save all variables used for local declaration -->
<admst:variable name="requiredderivateforddx" value="no"/>
<admst:variable name="ddxinsidederivate" value="no"/>

<!-- Skip all probe/derivate stuff. -->
<admst:variable name="SkipProbe" value="no"/>  

<!-- Suppress the non-derivate part of variable declarations. -->
<admst:variable name="SkipDCL" value="no"/>

<!-- List of top-level variable names that are assigned to in the
     model initialization code. -->
<admst:variable name="model_vars"/>

<!-- List of top-level variable names that are not assigned to in the
     model initialization code. -->
<admst:variable name="model_local_vars"/>

<!-- List of top-level variable names that are assigned to in the
     instance initialization code. -->
<admst:variable name="instance_vars"/>

<!-- List of top-level variable names that are not assigned to in the
     instance initialization code. -->
<admst:variable name="instance_local_vars"/>

<!-- List of lhs from V() <+ ... contributions.  These are not handled
     by the standard adms jacobian formulation, so we do this
     ourselves. -->
<admst:variable name="branches"/>

<!-- List of lhs from V() <+ ... contributions that might be collapsed.
     We don't know for sure until the topology method is called at run
     time. -->
<admst:variable name="collapsable"/>

<!-- List of the current probes found in expression right hand sides.
     We handle only I(n) where n is a module port.  If found, we have
     to set up the pointers, etc. -->
<admst:variable name="curprobes"/>

<!-- When set to 'yes', emit '#defines' in output.  I'm not sure what
     these were good for other than debugging. -->
<admst:variable name="emit_defines" value="no"/>

<!-- Global used by incrementer template -->
<admst:variable name="inc_list" value=""/>

<!-- ---------------------------------------------------------------------- -->
<!-- Math helpers -->
<!--
  These are used to construct expressions for output, filtering out
  dead parts due to 0.0 and 1.0 constants.
-->

<!--
  NOTE:  The parser will always put parens around a negative number,
  e.g., -1 returns (-1).  This prevents a double-minus from being
  generated in subtraction or unary minus, which might be taken as a
  decrement operator in C/C++ code.
-->

<!-- Left operand and return value. -->
<admst:variable name="leftval"/>

<!-- Right operand. -->
<admst:variable name="rightval"/>

<admst:template match="math:is_zero">
  <admst:choose>
    <admst:when test="[.='0.0' or .='(0.0)' or .='((0.0))' or
        .='0' or .='(0)' or .='((0))']">
      <admst:return name="result" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="result" value="no"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="math:is_one">
  <admst:choose>
    <admst:when test="[.='1.0' or .='(1.0)' or .='((1.0))' or
        .='1' or .='(1)' or .='((1))']">
      <admst:return name="result" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="result" value="no"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="math:is_mone">
  <admst:choose>
    <admst:when test="[.='-1.0' or .='(-1.0)' or .='((-1.0))' or
        .='-1' or .='(-1)' or .='((-1))']">
      <admst:return name="result" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="result" value="no"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
   $leftval <== $leftval * $rightval
   Note that we don't add parentheses here.  The result only needs
   parentheses when used as the denominator in divide, and the divide
   template adds these.
-->
<admst:template match="math:mult">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' or
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:when test="[math:is_one($rightval)/value='yes']"/>
    <admst:when test="[math:is_one($leftval)/value='yes']">
      <admst:variable name="leftval" value="$rightval"/>
    </admst:when>
    <admst:when test="[math:is_mone($rightval)/value='yes']">
      <admst:variable name="leftval" value="(-$leftval)"/>
    </admst:when>
    <admst:when test="[math:is_mone($leftval)/value='yes']">
      <admst:variable name="leftval" value="(-$rightval)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="$leftval*$rightval"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
   $leftval <== $leftval / ($rightval)
   Note that the denominator is enclosed in parentheses, which are needed
   if this is from a multiply or divide.
-->
<admst:template match="math:div">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' or
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:when test="[math:is_one($rightval)/value='yes']"/>
    <admst:when test="[math:is_mone($rightval)/value='yes']">
      <admst:variable name="leftval" value="(-$leftval)"/>
    </admst:when>
    <admst:when test="[$leftval=$rightval]">
      <admst:variable name="leftval" value="1.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="$leftval/($rightval)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
   $leftval <== $leftval + $rightval
-->
<admst:template match="math:add">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' and
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:when test="[math:is_zero($rightval)/value='yes']"/>
    <admst:when test="[math:is_zero($leftval)/value='yes']">
      <admst:variable name="leftval" value="$rightval"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="$leftval+$rightval"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
   $leftval <== ($leftval + $rightval)
   As above, but add parentheses around two terms.
-->
<admst:template match="math:add:emparen">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' and
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:when test="[math:is_zero($rightval)/value='yes']"/>
    <admst:when test="[math:is_zero($leftval)/value='yes']">
      <admst:variable name="leftval" value="$rightval"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="($leftval+$rightval)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
   $leftval <== $leftval - $rightval
-->
<admst:template match="math:sub">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' and
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:when test="[math:is_zero($rightval)/value='yes']"/>
    <admst:when test="[math:is_zero($leftval)/value='yes']">
      <admst:variable name="leftval" value="(-$rightval)"/>
    </admst:when>
    <admst:when test="[$leftval=$rightval]">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="$leftval-$rightval"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
   $leftval <== ($leftval - $rightval)
   As for sub, but add parentheses around two terms.
-->
<admst:template match="math:sub:emparen">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' and
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:when test="[math:is_zero($rightval)/value='yes']"/>
    <admst:when test="[math:is_zero($leftval)/value='yes']">
      <admst:variable name="leftval" value="(-$rightval)"/>
    </admst:when>
    <admst:when test="[$leftval=$rightval]">
      <admst:variable name="leftval" value="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="($leftval-$rightval)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
  If $leftval is empty, set it to 0.0, otherwise if it is not 0.0 add
  parentheses around it.
-->
<admst:template match="math:emparen">
  <admst:if test="[$leftval='']">
    <admst:variable name="leftval" value="0.0"/>
  </admst:if>
  <admst:if test="[math:is_zero($leftval)/value='no']">
    <admst:variable name="leftval" value="($leftval)"/>
  </admst:if>
</admst:template>

<!--
  Return yes if the function is one of the single-argument built-in
  math functions.
-->
<admst:template match="math:isfunc:1">
  <admst:choose>
    <admst:when test="[name='abs' or name='acos' or name='asin' or
        name='atan' or name='acosh' or name='asinh' or name='atanh' or
        name='cos' or name='cosh' or name='exp' or
        name='limexp' or name='\$limexp' or name='ln' or name='log' or
        name='sin' or name='sinh' or name='sqrt' or name='tan' or
        name='tanh']">
      <admst:return name="result" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="result" value="no"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
  Return yes if the function is one of the two-argument built-in
  math functions.
-->
<admst:template match="math:isfunc:2">
  <admst:choose>
    <admst:when test="[name='add' or name='atan2' or name='div' or
        name='hypot' or name='max' or name='min' or name='mult' or
        name='pow']">
      <admst:return name="result" value="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="result" value="no"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- Integer variation of math:sub -->
<admst:template match="math:subi">
  <admst:choose>
    <admst:when test="[math:is_zero($leftval)/value='yes' and
        math:is_zero($rightval)/value='yes']">
      <admst:variable name="leftval" value="0"/>
    </admst:when>
    <admst:when test="[math:is_zero($rightval)/value='yes']"/>
    <admst:when test="[math:is_zero($leftval)/value='yes']">
      <admst:variable name="leftval" value="(-$rightval)"/>
    </admst:when>
    <admst:when test="[$leftval=$rightval]">
      <admst:variable name="leftval" value="0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leftval" value="$leftval-$rightval"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- Array index computation -->
<admst:template match="math:ixval">
  <admst:choose>
    <admst:when test="[minsize<maxsize]">
      <admst:variable name="rightval" value="%(minsize)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="rightval" value="$leftval"/>
      <admst:variable name="leftval" value="%(minsize)"/>
    </admst:otherwise>
  </admst:choose>
  <admst:apply-templates select="." match="math:subi"/>
</admst:template>

<!-- Array size computation -->
<admst:template match="math:asizeval">
  <admst:choose>
    <admst:when test="[minsize<maxsize]">
      <admst:variable name="minsz" value="%(minsize)"/>
      <admst:choose>
        <admst:when test="[$minsz='0']">
          <admst:variable name="leftval" value="%(maxsize)+1"/>
        </admst:when>
        <admst:when test="[$minsz='1']">
          <admst:variable name="leftval" value="%(maxsize)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="leftval" value="%(maxsize)-%(minsize)+1"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="maxsz" value="%(maxsize)"/>
      <admst:choose>
        <admst:when test="[$maxsz='0']">
          <admst:variable name="leftval" value="%(minsize)+1"/>
        </admst:when>
        <admst:when test="[$maxsz='1']">
          <admst:variable name="leftval" value="%(minsize)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="leftval" value="%(minsize)-%(maxsize)+1"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Return an incremented digit on each call, starting from 0.  To clear,
  reset the $inc_list variable to "".
-->
<admst:template match="incrementer">
  <admst:variable name="cnt" value="%(count($inc_list)-1)"/>
  <admst:push into="$inc_list" select="$cnt"/>
  <admst:return name="value" value="$cnt"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!-- Indentation -->
<!--
  This implelemts an indentation capability for output, making the
  code readable.  Basically, one needs to call push_indent and pop_indent
  as appropriate, and begin each output line with $(indent).
-->
<admst:variable name="nobrackets"/>
<admst:variable name="noparens"/>
<admst:variable name="indent_level"/>
<admst:variable name="indent"/>
<admst:variable name="id1" value="    "/>
<admst:variable name="id2" value="    $id1"/>
<admst:variable name="id3" value="    $id2"/>
<admst:variable name="id4" value="    $id3"/>
<admst:variable name="id5" value="    $id4"/>
<admst:variable name="id6" value="    $id5"/>
<admst:variable name="id7" value="    $id6"/>
<admst:variable name="id8" value="    $id7"/>
<admst:variable name="id9" value="    $id8"/>
<admst:variable name="id10" value="    $id9"/>
<admst:variable name="id11" value="    $id10"/>
<admst:variable name="id12" value="    $id11"/>
<admst:variable name="id13" value="    $id12"/>
<admst:variable name="id14" value="    $id13"/>
<admst:variable name="id15" value="    $id14"/>
<admst:variable name="id16" value="    $id15"/>
<admst:variable name="id17" value="    $id16"/>
<admst:variable name="id18" value="    $id17"/>

<admst:template match="push_indent">
  <admst:choose>
    <admst:when test="[$indent_level='18']">
      <admst:variable name="indent_level" select="18"/>
      <admst:variable name="indent" select="$id18"/>
    </admst:when>
    <admst:when test="[$indent_level='16']">
      <admst:variable name="indent_level" select="17"/>
      <admst:variable name="indent" select="$id17"/>
    </admst:when>
    <admst:when test="[$indent_level='15']">
      <admst:variable name="indent_level" select="16"/>
      <admst:variable name="indent" select="$id16"/>
    </admst:when>
    <admst:when test="[$indent_level='14']">
      <admst:variable name="indent_level" select="15"/>
      <admst:variable name="indent" select="$id15"/>
    </admst:when>
    <admst:when test="[$indent_level='13']">
      <admst:variable name="indent_level" select="14"/>
      <admst:variable name="indent" select="$id14"/>
    </admst:when>
    <admst:when test="[$indent_level='12']">
      <admst:variable name="indent_level" select="13"/>
      <admst:variable name="indent" select="$id13"/>
    </admst:when>
    <admst:when test="[$indent_level='11']">
      <admst:variable name="indent_level" select="12"/>
      <admst:variable name="indent" select="$id12"/>
    </admst:when>
    <admst:when test="[$indent_level='10']">
      <admst:variable name="indent_level" select="11"/>
      <admst:variable name="indent" select="$id11"/>
    </admst:when>
    <admst:when test="[$indent_level='9']">
      <admst:variable name="indent_level" select="10"/>
      <admst:variable name="indent" select="$id10"/>
    </admst:when>
    <admst:when test="[$indent_level='8']">
      <admst:variable name="indent_level" select="9"/>
      <admst:variable name="indent" select="$id9"/>
    </admst:when>
    <admst:when test="[$indent_level='7']">
      <admst:variable name="indent_level" select="8"/>
      <admst:variable name="indent" select="$id8"/>
    </admst:when>
    <admst:when test="[$indent_level='6']">
      <admst:variable name="indent_level" select="7"/>
      <admst:variable name="indent" select="$id7"/>
    </admst:when>
    <admst:when test="[$indent_level='5']">
      <admst:variable name="indent_level" select="6"/>
      <admst:variable name="indent" select="$id6"/>
    </admst:when>
    <admst:when test="[$indent_level='4']">
      <admst:variable name="indent_level" select="5"/>
      <admst:variable name="indent" select="$id5"/>
    </admst:when>
    <admst:when test="[$indent_level='3']">
      <admst:variable name="indent_level" select="4"/>
      <admst:variable name="indent" select="$id4"/>
    </admst:when>
    <admst:when test="[$indent_level='2']">
      <admst:variable name="indent_level" select="3"/>
      <admst:variable name="indent" select="$id3"/>
    </admst:when>
    <admst:when test="[$indent_level='1']">
      <admst:variable name="indent_level" select="2"/>
      <admst:variable name="indent" select="$id2"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="indent_level" select="1"/>
      <admst:variable name="indent" select="$id1"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="pop_indent">
  <admst:choose>
    <admst:when test="[$indent_level='2']">
      <admst:variable name="indent_level" select="1"/>
      <admst:variable name="indent" select="$id1"/>
    </admst:when>
    <admst:when test="[$indent_level='3']">
      <admst:variable name="indent_level" select="2"/>
      <admst:variable name="indent" select="$id2"/>
    </admst:when>
    <admst:when test="[$indent_level='4']">
      <admst:variable name="indent_level" select="3"/>
      <admst:variable name="indent" select="$id3"/>
    </admst:when>
    <admst:when test="[$indent_level='5']">
      <admst:variable name="indent_level" select="4"/>
      <admst:variable name="indent" select="$id4"/>
    </admst:when>
    <admst:when test="[$indent_level='6']">
      <admst:variable name="indent_level" select="5"/>
      <admst:variable name="indent" select="$id5"/>
    </admst:when>
    <admst:when test="[$indent_level='7']">
      <admst:variable name="indent_level" select="6"/>
      <admst:variable name="indent" select="$id6"/>
    </admst:when>
    <admst:when test="[$indent_level='8']">
      <admst:variable name="indent_level" select="7"/>
      <admst:variable name="indent" select="$id7"/>
    </admst:when>
    <admst:when test="[$indent_level='9']">
      <admst:variable name="indent_level" select="8"/>
      <admst:variable name="indent" select="$id8"/>
    </admst:when>
    <admst:when test="[$indent_level='10']">
      <admst:variable name="indent_level" select="9"/>
      <admst:variable name="indent" select="$id9"/>
    </admst:when>
    <admst:when test="[$indent_level='11']">
      <admst:variable name="indent_level" select="10"/>
      <admst:variable name="indent" select="$id10"/>
    </admst:when>
    <admst:when test="[$indent_level='12']">
      <admst:variable name="indent_level" select="11"/>
      <admst:variable name="indent" select="$id11"/>
    </admst:when>
    <admst:when test="[$indent_level='13']">
      <admst:variable name="indent_level" select="12"/>
      <admst:variable name="indent" select="$id12"/>
    </admst:when>
    <admst:when test="[$indent_level='14']">
      <admst:variable name="indent_level" select="13"/>
      <admst:variable name="indent" select="$id13"/>
    </admst:when>
    <admst:when test="[$indent_level='15']">
      <admst:variable name="indent_level" select="14"/>
      <admst:variable name="indent" select="$id14"/>
    </admst:when>
    <admst:when test="[$indent_level='16']">
      <admst:variable name="indent_level" select="15"/>
      <admst:variable name="indent" select="$id15"/>
    </admst:when>
    <admst:when test="[$indent_level='17']">
      <admst:variable name="indent_level" select="16"/>
      <admst:variable name="indent" select="$id16"/>
    </admst:when>
    <admst:when test="[$indent_level='18']">
      <admst:variable name="indent_level" select="17"/>
      <admst:variable name="indent" select="$id17"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="indent_level" select="0"/>
      <admst:variable name="indent" select=""/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- End of preliminaries. ------------------------------------------------ -->

<!-- ---------------------------------------------------------------------- -->
<!--
  Compute node arguments of noise functions.
-->
<admst:template match="noisebranch">
  <admst:variable name="n1" select=""/>
  <admst:choose>
    <admst:when test="lhs[grounded='yes']">
      <admst:return name="noisebranch"
        value="%(lhs/branch/pnode/name),%(lhs/branch/pnode/name)"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="noisebranch"
        value="%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="af:print:expression">
  <admst:choose>
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="expression" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:return name="x" value="$expression"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="$(dx_%s)"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='probe']">
      <admst:fatal
  format="af:print:expression: probe not allowed inside analog function.\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='variable']">
      <admst:value-of select="name"/>
      <admst:variable name="variable" select="%s"/>
      <admst:return name="x" value="$variable"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:variable name="ddx" select="%s"/>
        <admst:choose>
          <admst:when test="[$variable='$ddx']">
            <admst:return name="dx.$ddx" value="1.0"/>
          </admst:when>
          <admst:when test="../..[input='yes']">
            <admst:return name="dx.$ddx" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="dx.$ddx" value="$(variable)_$ddx"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_unary']">
      <admst:if test="[name='plus']">
        <admst:variable name="op" select="+"/>
      </admst:if>
      <admst:if test="[name='minus']">
        <admst:variable name="op" select="-"/>
      </admst:if>
      <admst:if test="[name='not']">
        <admst:variable name="op" select="!"/>
      </admst:if>
      <admst:if test="[name='bw_not']">
        <admst:variable name="op" select="~"/>
      </admst:if>
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="arg1" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="($op$arg1)"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dy_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(+$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(+$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx+$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(-$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(-$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx-$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:when test="[$x='0.0' or $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' or $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x)"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="($y)"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="($x*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx*$y"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x+$y)"/>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:return name="dx.$df" value="($y+($dy*$x))"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:return name="dx.$df" value="($dx*$y)+$x"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:return name="dx.$df" value="$dy"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="(($dx*$y)+($x*$dy))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$(df))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-1/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-$dy/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-$x/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-($x*$dy)/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($y-$x)/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df"
                      value="(($y-($x*$dy))/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:return name="dx.$df" value="$dx"/>
                  </admst:when>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="$dx/$y"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($dx*$y)-$x)/($y*$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df"
                      value="($dx*$y-$x*$dy)/($y*$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='bw_equr']">
              <admst:return name="x" value="($x^~$y)"/>
            </admst:when>
            <admst:when test="[name='bw_equl']">
              <admst:return name="x" value="($x~^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_xor']">
              <admst:return name="x" value="($x^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_or']">
              <admst:return name="x" value="($x|$y)"/>
            </admst:when>
            <admst:when test="[name='bw_and']">
              <admst:return name="x" value="($x&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='or']">
              <admst:return name="x" value="($x||$y)"/>
            </admst:when>
            <admst:when test="[name='and']">
              <admst:return name="x" value="($x&amp;&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='equ']">
              <admst:return name="x" value="($x==$y)"/>
            </admst:when>
            <admst:when test="[name='multmod']">
              <admst:return name="x" value="fmod($x,$y)"/>
            </admst:when>
            <admst:when test="[name='notequ']">
              <admst:return name="x" value="($x!=$y)"/>
            </admst:when>
            <admst:when test="[name='lt']">
              <admst:return name="x" value="($x&lt;$y)"/>
            </admst:when>
            <admst:when test="[name='lt_equ']">
              <admst:return name="x" value="($x&lt;=$y)"/>
            </admst:when>
            <admst:when test="[name='gt']">
              <admst:return name="x" value="($x&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='gt_equ']">
              <admst:return name="x" value="($x&gt;=$y)"/>
            </admst:when>
            <admst:when test="[name='shiftr']">
              <admst:return name="x" value="($x&gt;&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='shiftl']">
              <admst:return name="x" value="($x&lt;&lt;$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-of select="name"/>
              <admst:error format="%s: function not handled\n"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:return name="dx.%s" value="0.0"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="z" select="%s"/>
      </admst:apply-templates>
      <admst:if test="[name='conditional']">
        <admst:return name="x" value="($x?$y:$z)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:return name="dx.%s" value="($x?$dy_%s:$dz_%s)"/>
        </admst:for-each>
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='function']">
      <admst:apply-templates select="." match="funcname">
        <admst:value-of select="returned('fname')/value"/>
        <admst:variable name="function" select="%s"/>
      </admst:apply-templates>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[not($args='')]">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args%s"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:value-of select="returned('dx.%s')/value"/>
            <admst:value-of select="name"/>
            <admst:variable name="arg$(index)_%s" select="%s"/>
          </admst:for-each>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[math:isfunc:1(.)/value='yes' or
            math:isfunc:2(.)/value='yes']">
          <admst:return name="x" value="_$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="name" select="%s"/>
            <admst:variable name="ret" select=""/>
            <admst:for-each select="../../arguments">
              <admst:if test="[not($ret='')]">
                <admst:variable name="ret" select="$ret+"/>
              </admst:if>
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="ret"
          select="$(ret)_d$(index)_$function($args)*($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="$ret"/>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:return name="x" value="$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:variable name="name" select="%s"/>
            <admst:variable name="darg" select=""/>
            <admst:for-each select="../../arguments">
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="darg"
                select="$darg,($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="d_$function($args$darg)"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='string']">
      <admst:value-of select="value"/>
      <admst:return name="x" value="&quot;%s&quot;"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="%s"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+18)"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+15)"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+12)"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+9)"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+6)"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+3)"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+2)"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+1)"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-1)"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-2)"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-3)"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-6)"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-9)"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-10)"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-12)"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-15)"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-18)"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="scalingunit"/>
          <admst:fatal
            format="af:print:expression: unknown scaling unit %s.\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <!-- for forloop -->
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:value-of select="../lhs/name"/>
        <admst:return name="x" value="%s = %s"/>
      </admst:apply-templates>
    </admst:when>
    <admst:otherwise>
      <admst:return name="x"
         value="un-handled datatype %(adms/datatypename)\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="af:print:derivate">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:choose>
            <admst:when test="[$args='']">
              <admst:variable name="args" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="args" select="$args,%s"/>
            </admst:otherwise>
          </admst:choose>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="function[name='\$fclose']">
          <admst:return name="x" value="$(indent)DVO.fclose($args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$display']">
          <admst:return name="x" value="$(indent)DVO.display(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fdisplay']">
          <admst:return name="x" value="$(indent)DVO.fdisplay(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$write']">
          <admst:return name="x" value="$(indent)DVO.write(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fwrite']">
          <admst:return name="x" value="$(indent)DVO.fwrite(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$monitor']">
          <admst:return name="x" value="$(indent)DVO.monitor(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fmonitor']">
          <admst:return name="x" value="$(indent)DVO.fmonitor(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$strobe']">
          <admst:return name="x" value="$(indent)DVO.strobe(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fstrobe']">
          <admst:return name="x" value="$(indent)DVO.fstrobe(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$warning']">
          <admst:return name="x" value="$(indent)DVO.warning(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$error']">
          <admst:return name="x" value="$(indent)DVO.error(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$finish']">
          <admst:fatal
  format="af:print:derivate: %(function/name) not supported in analog function.\n"/>
        </admst:when>
        <admst:when test="function[name='\$stop']">
          <admst:fatal
  format="af:print:derivate: %(function/name) not supported in analog function.\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal
  format="af:print:derivate: unsupported function %(function/name).\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="while" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:if test="whileblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="push_indent"/>
      </admst:if>
      <admst:apply-templates select="whileblock" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:if test="whileblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:if>
      <admst:return name="x" value="$(indent)while ($while)\n$whileblock"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="initial" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="condition" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="condition" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="update" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="update" select="%s"/>
      </admst:apply-templates>
      <admst:if test="forblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="push_indent"/>
      </admst:if>
      <admst:apply-templates select="forblock" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="forblock" select="%s"/>
      </admst:apply-templates>
      <admst:if test="forblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:if>
      <admst:return name="x"
        value="$(indent)for ($initial; $condition; $update)\n$forblock"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:if test="then/adms[datatypename!='block']">
        <admst:apply-templates select="." match="push_indent"/>
      </admst:if>
      <admst:apply-templates select="then" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
      </admst:apply-templates>
      <admst:if test="then/adms[datatypename!='block']">
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:if>
      <admst:choose>
        <admst:when test="else">
          <admst:if test="then/adms[datatypename!='block']">
            <admst:apply-templates select="." match="push_indent"/>
          </admst:if>
          <admst:apply-templates select="else" match="af:print:derivate">
            <admst:value-of select="returned('x')/value"/>
            <admst:variable name="else" select="%s"/>
          </admst:apply-templates>
          <admst:if test="then/adms[datatypename!='block']">
            <admst:apply-templates select="." match="pop_indent"/>
          </admst:if>
          <admst:return name="x"
            value="$(indent)if ($if)\n$then$(indent)else\n$else"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="x" value="$(indent)if ($if)\n$then"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="$(indent)switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="case %s:"/>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[defaultcase='yes']">
            <admst:variable name="case" select="$case$(indent)default:\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="case" select="$case$(indent)$condition\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:apply-templates select="code" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s$(indent)break;\n"/>
        </admst:apply-templates>
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:for-each>
      <admst:return name="x" value="$case$(indent)}\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal
  format="af:print:derivate: contribution not allowed inside analog function.\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:value-of select="lhs/name"/>
      <admst:variable name="lhs" select="%s"/>
      <admst:apply-templates select="." match="push_indent"/>
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:variable name="rhs" select=""/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="rhs" select="$rhs$(indent)$(lhs)_%s = %s;\n"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:apply-templates select="." match="pop_indent"/>
      <admst:return name="x" value="$(indent){\n$rhs$(indent)}\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="push_indent"/>
        <admst:apply-templates select="." match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block%s"/>
        </admst:apply-templates>
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:for-each>
      <admst:return name="x" value="$(indent){\n$block$(indent)}\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="x"
         value="un-handled datatype %(adms/datatypename)\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="af:print">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:choose>
            <admst:when test="[$args='']">
              <admst:variable name="args" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="args" select="$args,%s"/>
            </admst:otherwise>
          </admst:choose>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="function[name='\$fclose']">
          <admst:return name="x" value="$(indent)DVO.fclose($args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$display']">
          <admst:return name="x" value="$(indent)DVO.display(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fdisplay']">
          <admst:return name="x" value="$(indent)DVO.fdisplay(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$write']">
          <admst:return name="x" value="$(indent)DVO.write(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fwrite']">
          <admst:return name="x" value="$(indent)DVO.fwrite(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$monitor']">
          <admst:return name="x" value="$(indent)DVO.monitor(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fmonitor']">
          <admst:return name="x" value="$(indent)DVO.fmonitor(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$strobe']">
          <admst:return name="x" value="$(indent)DVO.strobe(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$fstrobe']">
          <admst:return name="x" value="$(indent)DVO.fstrobe(0,0,%(function/unique_id),$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$warning']">
          <admst:return name="x" value="$(indent)DVO.warning(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$error']">
          <admst:return name="x" value="$(indent)DVO.error(0,0,$args);\n"/>
        </admst:when>
        <admst:when test="function[name='\$finish']">
          <admst:fatal
  format="af:print:derivate: %(function/name) not supported in analog function.\n"/>
        </admst:when>
        <admst:when test="function[name='\$stop']">
          <admst:fatal
  format="af:print:derivate: %(function/name) not supported in analog function.\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal
            format="af:print: unsupported function %(function/name).\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="while" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:if test="whileblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="push_indent"/>
      </admst:if>
      <admst:apply-templates select="whileblock" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:if test="whileblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:if>
      <admst:return name="x" value="$(indent)while ($while)\n$whileblock"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="initial" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="condition" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="condition" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="update" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="update" select="%s"/>
      </admst:apply-templates>
      <admst:if test="forblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="push_indent"/>
      </admst:if>
      <admst:apply-templates select="forblock" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="forblock" select="%s"/>
      </admst:apply-templates>
      <admst:if test="forblock/adms[datatypename!='block']">
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:if>
      <admst:return name="x"
        value="$(indent)for ($initial; $condition; $update)\n$forblock"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:if test="then/adms[datatypename!='block']">
        <admst:apply-templates select="." match="push_indent"/>
      </admst:if>
      <admst:apply-templates select="then" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
      </admst:apply-templates>
      <admst:if test="then/adms[datatypename!='block']">
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:if>
      <admst:choose>
        <admst:when test="else">
          <admst:if test="else/adms[datatypename!='block']">
            <admst:apply-templates select="." match="push_indent"/>
          </admst:if>
          <admst:apply-templates select="else" match="af:print">
            <admst:value-of select="returned('x')/value"/>
            <admst:variable name="else" select="%s"/>
          </admst:apply-templates>
          <admst:if test="else/adms[datatypename!='block']">
            <admst:apply-templates select="." match="pop_indent"/>
          </admst:if>
          <admst:return name="x"
            value="$(indent)if ($if)\n$then$(indent)else\n$else"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="x" value="$(indent)if ($if)\n$then"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="$(indent)switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="case %s:"/>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[defaultcase='yes']">
            <admst:variable name="case" select="$case$(indent)default:\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="case" select="$case$(indent)$condition\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:apply-templates select="code" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s$(indent)break;\n"/>
        </admst:apply-templates>
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:for-each>
      <admst:return name="x" value="$case$(indent)}\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal
        format="af:print: contribution not allowed inside analog function.\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:value-of select="../lhs/name"/>
        <admst:return name="x" value="$(indent)%s = %s;\n"/>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="push_indent"/>
        <admst:apply-templates select="." match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block%s"/>
        </admst:apply-templates>
        <admst:apply-templates select="." match="pop_indent"/>
      </admst:for-each>
      <admst:return name="x" value="$(indent){\n$block$(indent)}\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="x"
         value="un-handled datatype %(adms/datatypename)\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Outputs the type of a variable.  The type is either int, double, or
  char *.
-->
<admst:template match="vtype">
  <admst:choose>
    <admst:when test="[type='integer']">int</admst:when>
    <admst:when test="[type='real']">double</admst:when>
    <admst:when test="[type='string']">char*</admst:when>
    <admst:otherwise>
      <admst:fatal format="vtype: unexpected variable type %(type).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" value="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" value="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" value="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" value="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" value="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" value="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" value="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" value="=="/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:return name="bname" value="%%"/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" value="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" value="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" value="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" value="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" value="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" value="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" value="&lt;&lt;"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="bname: unknown operator type %(name).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="e">
  <admst:apply-templates select="."
    match="%(adms/datatypename)">$e</admst:apply-templates>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="ddx">
  <admst:apply-templates select="." match="%(adms/datatypename)"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="ddxname">
  <admst:return name="ddxname"
    value="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="dxname">
  <admst:return name="dxname"
    value="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="variable">
  <admst:variable name="vv" value="%(name)"/>
  <admst:choose>
    <admst:when test="$model_vars[name=$vv]">
      <admst:variable name="e" select="model->%(name)"/>
    </admst:when>
    <admst:when test="$instance_vars[name=$vv]">
      <admst:choose>
        <admst:when test="[$inst_to_model='yes']">
          <admst:fatal
 format="variable: unexpeccted instance dependency in model initialization.\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="inst->%(name)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[input='yes' and parametertype='model']">
      <admst:variable name="e" select="model->%(name)"/>
    </admst:when>
    <admst:when test="[input='yes' and parametertype='instance']">
      <admst:choose>
        <admst:when test="[$inst_to_model='yes']">
          <admst:variable name="e" select="model->%(name)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="inst->%(name)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[input='no' and scope='global_model']">
      <admst:variable name="e" select="model->%(name)"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_instance']">
      <admst:choose>
        <admst:when test="[$inst_to_model='yes']">
          <admst:fatal
 format="variable: unexpeccted instance dependency in model initialization.\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="inst->%(name)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[parametertype='instance' and input='no' and
        not(nilled(attribute))]">
      <admst:variable name="e" select="inst->%(name)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="%(name)"/>
    </admst:otherwise>
  </admst:choose>
  <admst:variable name="ep" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:variable name="ep"
  select="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>
  <admst:if test="$qprobe">
    <admst:variable name="eq" select="0.0"/>
    <admst:if test="[insource='yes']">
      <admst:if-inside select="$qprobe" list="%(probe)">
        <admst:variable name="eq"
  select="%(name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
      </admst:if-inside>
    </admst:if>
    <admst:variable name="epq" select="0.0"/>
    <admst:if test="[insource='yes']">
      <admst:if-inside select="$pprobe" list="%(probe)">
        <admst:if-inside select="$qprobe" list="%(probe)">
          <admst:if test="ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
              .=$pprobe/branch/nnode]">
            <admst:variable name="epq"
              select="%(ddxname(.)/[name='ddxname']/value)"/>
          </admst:if>
        </admst:if-inside>
      </admst:if-inside>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->

<admst:template match="array">
  <admst:variable name="tn" value="%(index/datatypename)"/>
  <admst:apply-templates select="index" match="$tn"/>
  <admst:variable name="leftval" value="$e"/>
  <admst:apply-templates select="variable" match="math:ixval"/>
  <admst:variable name="ixval" value="$leftval"/>
  <admst:apply-templates select="variable" match="variable"/>
  <admst:variable name="e" select="$e[$ixval]"/>
  <admst:if test="[$ep != '0.0' and $ep !='']">
    <admst:variable name="ep" select="$ep[$ixval]"/>
  </admst:if>
  <admst:if test="$qprobe">
    <admst:if test="[$eq != '0.0' and $eq !='']">
      <admst:variable name="eq" select="$eq[$ixval]"/>
    </admst:if>
    <admst:if test="[$epq != '0.0' and $epq !='']">
      <admst:variable name="epq" select="$epq[$ixval]"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->

<admst:template match="probe">
  <admst:choose>
    <admst:when test="[nature=discipline/potential]">
      <admst:choose>
        <admst:when test="branch/nnode[grounded='no']">
          <admst:variable name="e"
            select="(NP(%(branch/pnode/name))-NP(%(branch/nnode/name)))"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="NP(%(branch/pnode/name))"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[.=$pprobe]">
          <admst:variable name="ep" select="1.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="0.0"/>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$qprobe">
        <admst:choose>
          <admst:when test="[.=$qprobe]">
            <admst:variable name="eq" select="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="0.0"/>
          </admst:otherwise>
        </admst:choose>
        <admst:variable name="epq" select="0.0"/>
      </admst:if>
    </admst:when>

    <admst:when test="[nature=discipline/flow]">
      <admst:choose>
        <admst:when test="[branch/nnode/grounded='yes']">
          <!--
            We get here for I(ext), so this needs to be interpreted
            as I(ext,ext) but only if ext is an external node.
          -->
          <admst:fatal
            format="Can't handle I(node) with node not external, exiting.\n"
            test="[branch/pnode/location!='external']"/>
          <admst:variable name="e"
            select="BR(%(branch/pnode/name),%(branch/pnode/name))"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e"
            select="BR(%(branch/pnode/name),%(branch/nnode/name))"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="ep" select="1.0"/>
      <admst:if test="$qprobe">
        <admst:variable name="eq" select="0.0"/>
        <admst:variable name="epq" select="0.0"/>
      </admst:if>
    </admst:when>
    <admst:otherwise>
      <admst:fatal
        format="probe: can't resolve whether %(.) is potential or flow.\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="node">
  <admst:fatal format="node: module node not expected, %(name).\n"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="string">
  <admst:variable name="e" select="&quot;%(value)&quot;"/>
  <admst:variable name="ep" select="0.0"/>
  <admst:if test="$qprobe">
    <admst:variable name="eq" select="0.0"/>
    <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="number">
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:variable name="e" select="%(value)"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:variable name="e" select="(%(value)*1.0e+18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:variable name="e" select="(%(value)*1.0e+15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:variable name="e" select="(%(value)*1.0e+12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:variable name="e" select="(%(value)*1.0e+9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:variable name="e" select="(%(value)*1.0e+6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:variable name="e" select="(%(value)*1.0e+3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:variable name="e" select="(%(value)*1.0e+2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:variable name="e" select="(%(value)*1.0e+1)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:variable name="e" select="(%(value)*1.0e-1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:variable name="e" select="(%(value)*1.0e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:variable name="e" select="(%(value)*1.0e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:variable name="e" select="(%(value)*1.0e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:variable name="e" select="(%(value)*1.0e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:variable name="e" select="(%(value)*1.0e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:variable name="e" select="(%(value)*1.0e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:variable name="e" select="(%(value)*1.0e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:variable name="e" select="(%(value)*1.0e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="number: unknown scaling unit %(scalingunit).\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="$qprobe">
    <admst:variable name="eq" select="0.0"/>
    <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="mapply_unary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:choose>
    <admst:when test="[name='plus']"/>
    <admst:when test="[name='minus']">
      <admst:if test="[math:is_zero($e)/value='no']">
        <admst:variable name="e" select="(-$e)"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="[math:is_zero($e)/value='yes']">
          <admst:variable name="e" select="1"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="!$e"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="[math:is_zero($e)/value='yes']">
          <admst:variable name="e" select="(-1U)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="~$e"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="mapply_unary: unknown operator %(name).\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[math:is_zero($e)/value='yes']">
      <admst:variable name="ep" select="0.0"/>
    </admst:when>
    <admst:when test="[math:is_zero($ep)/value='yes']"/>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']"/>
        <admst:when test="[name='minus']">
          <admst:variable name="ep" select="(-$ep)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="0.0"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="$qprobe">
    <admst:choose>
      <admst:when test="[math:is_zero($e)/value='yes']">
        <admst:variable name="eq" select="0.0"/>
      </admst:when>
      <admst:when test="[math:is_zero($eq)/value='yes']"/>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[name='plus']"/>
          <admst:when test="[name='minus']">
            <admst:variable name="eq" select="(-$eq)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="0.0"/>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
    <admst:choose>
      <admst:when test="[math:is_zero($eq)/value='yes']">
        <admst:variable name="epq" select="0.0"/>
      </admst:when>
      <admst:when test="[math:is_zero($epq)/value='yes']"/>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[name='plus']"/>
          <admst:when test="[name='minus']">
            <admst:variable name="epq" select="(-$epq)"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="epq" select="0.0"/>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="mapply_binary">
  <admst:variable name="np" value="$noparens"/>
  <admst:variable name="noparens" value="no"/>
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" select="$e"/>
  <admst:variable name="xp" select="$ep"/>
  <admst:variable name="xq" select="$eq"/>
  <admst:variable name="xpq" select="$epq"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" select="$e"/>
  <admst:variable name="yp" select="$ep"/>
  <admst:variable name="yq" select="$eq"/>
  <admst:variable name="ypq" select="$epq"/>
  <admst:choose>
    <admst:when test="[name='addp']">
      <admst:variable name="leftval" value="$x"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:choose>
        <admst:when test="[$np='yes']">
          <admst:apply-templates select="." match="math:add"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="." match="math:add:emparen"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="e" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:variable name="leftval" value="$x"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:choose>
        <admst:when test="[$np='yes']">
          <admst:apply-templates select="." match="math:sub"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="." match="math:sub:emparen"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="e" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:variable name="leftval" value="$x"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="e" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:variable name="leftval" value="$x"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:apply-templates select="." match="math:div"/>
      <admst:variable name="e" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:variable name="e" select="fmod($x,$y)"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[$np='yes']">
          <admst:variable name="e"
            select="$x%(bname(.)/[name='bname']/value)$y"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e"
            select="($x%(bname(.)/[name='bname']/value)$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="[math:is_zero($x)/value='yes']">
    <admst:variable name="xp" value="0.0"/>
  </admst:if>
  <admst:if test="[math:is_zero($y)/value='yes']">
    <admst:variable name="yp" value="0.0"/>
  </admst:if>
  <admst:choose>
    <admst:when test="[name='addp']">
      <!-- ep = ($xp + $yp) -->
      <admst:variable name="leftval" value="$xp"/>
      <admst:variable name="rightval" value="$yp"/>
      <admst:apply-templates select="." match="math:add:emparen"/>
      <admst:variable name="ep" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='addm']">
      <!-- ep = ($xp - $yp) -->
      <admst:variable name="leftval" value="$xp"/>
      <admst:variable name="rightval" value="$yp"/>
      <admst:apply-templates select="." match="math:sub:emparen"/>
      <admst:variable name="ep" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='multtime']">
      <!-- ep = ($xp*$y + $x*$yp) -->
      <admst:variable name="leftval" value="$xp"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="ep" select="$leftval"/>
      <admst:variable name="leftval" value="$x"/>
      <admst:variable name="rightval" value="$yp"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="rightval" value="$leftval"/>
      <admst:variable name="leftval" value="$ep"/>
      <admst:apply-templates select="." match="math:add:emparen"/>
      <admst:variable name="ep" select="$leftval"/>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <!-- ep = ($xp/$y - $x*$yp/$y/$y), or
           ep = ($xp - $x*$yp/$y)/$y -->
      <admst:variable name="leftval" value="$x"/>
      <admst:variable name="rightval" value="$yp"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:apply-templates select="." match="math:div"/>
      <admst:variable name="rightval" value="$leftval"/>
      <admst:variable name="leftval" value="$xp"/>
      <admst:apply-templates select="." match="math:sub:emparen"/>
      <admst:variable name="rightval" value="$y"/>
      <admst:apply-templates select="." match="math:div"/>
      <admst:variable name="ep" select="$leftval"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" select="0.0"/>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="$qprobe">
    <admst:if test="[math:is_zero($x)/value='yes']">
      <admst:variable name="xq" value="0.0"/>
    </admst:if>
    <admst:if test="[math:is_zero($y)/value='yes']">
      <admst:variable name="yq" value="0.0"/>
    </admst:if>
    <admst:choose>
      <admst:when test="[name='addp']">
        <!-- eq = ($xq + $yq) -->
        <admst:variable name="leftval" value="$xq"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="eq" select="$leftval"/>
      </admst:when>
      <admst:when test="[name='addm']">
        <!-- eq = ($xq - $yq) -->
        <admst:variable name="leftval" value="$xq"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:sub:emparen"/>
        <admst:variable name="eq" select="$leftval"/>
      </admst:when>
      <admst:when test="[name='multtime']">
        <!-- eq = ($xq*$y + $x*$yq) -->
        <admst:variable name="leftval" value="$xq"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="eq" select="$leftval"/>
        <admst:variable name="leftval" value="$x"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$eq"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="eq" select="$leftval"/>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <!-- eq = ($xq/$y - $x*$yq/$y/$y), so 
             eq = ($xq - $x*$yq/$y)/$y -->
        <admst:variable name="leftval" value="$x"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:div"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$xq"/>
        <admst:apply-templates select="." match="math:sub:emparen"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:div"/>
        <admst:variable name="eq" select="$leftval"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="eq" select="0.0"/>
      </admst:otherwise>
    </admst:choose>

    <admst:if test="[math:is_zero($xq)/value='yes']">
      <admst:variable name="xpq" value="0.0"/>
    </admst:if>
    <admst:if test="[math:is_zero($yq)/value='yes']">
      <admst:variable name="ypq" value="0.0"/>
    </admst:if>
    <admst:choose>
      <admst:when test="[name='addp']">
        <!-- epq = ($xpq + $ypq) -->
        <admst:variable name="leftval" value="$xpq"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>
      <admst:when test="[name='addm']">
        <!-- epq = ($xpq - $ypq) -->
        <admst:variable name="leftval" value="$xpq"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:sub:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>
      <admst:when test="[name='multtime']">
        <!-- epq = ($xpq*$y + $xp*$yq + $xq*$yp + $x*$yqp) -->
        <admst:variable name="leftval" value="$xpq"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="$xp"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="$xq"/>
        <admst:variable name="rightval" value="$yp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="$x"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:apply-templates select="." match="math:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <!-- epq = ($xpq/$y - ($xp*$yq + $xq*$yp + $x*$ypq)/$y/$y +
                    2*$x*$yp*$yq/$y/$y/$y), or
             epq = ($xpq - ($xp*$yq + $xq*$yp + $x*$ypq -
                    2*$x*$yp*$yq/$y)/$y)/$y -->
        <admst:variable name="leftval" value="2.0"/>
        <admst:variable name="rightval" value="$x"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$yp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:div"/>
        <admst:variable name="temp" value="$leftval"/>

        <admst:variable name="leftval" value="$x"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="tmpval" value="$leftval"/>
        <admst:variable name="leftval" value="$xq"/>
        <admst:variable name="rightval" value="$yp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$tmpval"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="tmpval" value="$leftval"/>
        <admst:variable name="leftval" value="$xp"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$tmpval"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="rightval" value="$temp"/>
        <admst:apply-templates select="." match="math:sub:emparen"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:div"/>

        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$xpq"/>
        <admst:apply-templates select="." match="math:sub:emparen"/>
        <admst:variable name="rightval" value="$y"/>
        <admst:apply-templates select="." match="math:div"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="mapply_ternary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" select="$e"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" select="$e"/>
  <admst:variable name="yp" select="$ep"/>
  <admst:variable name="yq" select="$eq"/>
  <admst:variable name="ypq" select="$epq"/>
  <admst:apply-templates select="arg3" match="ddx"/>
  <admst:variable name="z" select="$e"/>
  <admst:variable name="zp" select="$ep"/>
  <admst:variable name="zq" select="$eq"/>
  <admst:variable name="zpq" select="$epq"/>
  <admst:variable name="e" select="($x?$y:$z)"/>
  <admst:variable name="ep" select="($x?$yp:$zp)"/>
  <admst:if test="$qprobe">
    <admst:variable name="eq" select="($x?$yq:$zq)"/>
    <admst:variable name="epq" select="($x?$ypq:$zpq)"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']">
      <admst:return name="fname" value="fabs"/>
    </admst:when>
    <admst:when test="[name='log']">
      <admst:return name="fname" value="log10"/>
    </admst:when>
    <admst:when test="[name='ln']">
      <admst:return name="fname" value="logE"/>
    </admst:when>
    <admst:when test="[name='\$limexp']">
      <admst:return name="fname" value="limexp"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="fname" value="%(name)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="function">
  <admst:variable name="args" select=""/>
  <admst:variable name="pargs" select=""/>
  <admst:variable name="qargs" select=""/>
  <admst:choose>

    <admst:when test="[name='absdelay' or name='delay']">
      <admst:assert test="arguments[count(.)=2]"
        format="%(name): should have two arguments exactly\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="ckt->va_absdelay($args)"/>
    </admst:when>

    <admst:when test="[name='\$abstime' or name='\$realtime']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="ckt->CKTtime"/>
    </admst:when>

    <admst:when test="[name='analysis']">
      <admst:assert test="arguments[count(.)=1]"
        format="%(name): should have one argument exactly\n"/>
      <admst:variable name="arg1" select="%(arguments[1])"/>
      <admst:variable name="e" select="ckt->va_analysis($arg1)"/>
    </admst:when>

    <admst:when test="[name='ceil']">
      <admst:assert test="arguments[count(.)=1]"
        format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="ceil($e)"/>
    </admst:when>

    <!--
      cfunc("foobar",1,2,3) maps to foobar(1,2,3)
      Note how quotes are stripped below, took a while to find
      how to do this.
    -->
    <admst:when test="[name='cfunc']">
      <admst:for-each select="arguments">
        <admst:if test="[position(.)!=1]">
          <admst:if test="[$args!='']">
            <admst:variable name="args" select="$args,"/>
          </admst:if>
          <admst:apply-templates select="." match="ddx"/>
          <admst:variable name="args" select="$args$e"/>
        </admst:if>
      </admst:for-each>
      <admst:variable name="arg1" select="%(arguments[1]/value)"/>
      <admst:variable name="e" select="$arg1($args)"/>
    </admst:when>

    <admst:when test="[name='ddt']">
      <admst:assert test="[count(arguments)=1 or count(arguments)=2]"
        format="%(name): should have one or two arguments\n"/>
      <admst:choose>
        <admst:when test="[$chk_purity='yes']">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <!-- OBSOLETE
        <admst:when test="[$DDTFUNC='twopass' and $loadpass2='no']">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="args" select="$e"/>
          <admst:if test="[count(arguments)=2]">
            <admst:apply-templates select="arguments[2]" match="ddx"/>
            <admst:variable name="args" select="$args,$e"/>
          </admst:if>
          <admst:variable name="e"
            select="ckt->va_ddt(inst->STATE_ddt_%(unique_id),$args)"/>
        </admst:when>
        -->
        <admst:when test="[$DDTFUNC='onepass']">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="xp" select="$ep"/>
          <admst:variable name="xq" select="$eq"/>
          <admst:variable name="xpq" select="$epq"/>
          <admst:variable name="args" select="$e"/>
          <admst:if test="[count(arguments)=2]">
            <admst:apply-templates select="arguments[2]" match="ddx"/>
            <admst:variable name="args" select="$args,$e"/>
          </admst:if>
          <admst:variable name="e"
            select="ckt->va_ddt(inst->STATE_ddt_%(unique_id),$args)"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" select="$e"/>
          <admst:variable name="xp" select="$ep"/>
          <admst:variable name="xq" select="$eq"/>
          <admst:variable name="xpq" select="$epq"/>
          <admst:variable name="e" select="$x"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <admst:when test="[name='ddx']">
      <admst:assert test="arguments[count(.)=2]"
        format="%(name): should have two arguments exactly\n"/>
      <admst:assert test="arguments[2]/adms[datatypename='probe']"
        format="%(name): second argument is not a probe\n"/>
      <admst:variable name="arg1" path="arguments[1]"/>
      <admst:variable name="ddxprobe" path="arguments[2]"/>
      <admst:variable name="tpp" path="$pprobe"/>
      <admst:variable name="leftval" value="0.0"/>
      <admst:choose>
        <admst:when test="[$arg1/adms/datatypename='variable']">
          <admst:for-each select="$arg1/probe">
            <admst:variable name="pprobe" select="%(.)"/>
            <admst:choose>
              <admst:when test="[$SkipProbe='yes']"/>
              <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
                <admst:apply-templates select="$arg1" match="ddx"/>
                <admst:variable name="rightval" value="$ep"/>
                <admst:apply-templates select="." match="math:add"/>
              </admst:when>
              <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
                <admst:apply-templates select="$arg1" match="ddx"/>
                <admst:variable name="rightval" value="$ep"/>
                <admst:apply-templates select="." match="math:sub"/>
              </admst:when>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:fatal
  format="The first argument of ddx is not a simple variable and this was\n"/>
          <admst:fatal
  format="not fixed during processing for some reason.  Exiting.\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="." match="math:emparen"/>
      <admst:variable name="e" value="$leftval"/>
      <admst:variable name="pprobe" path="$tpp"/>
    </admst:when>

    <admst:when test="[name='flicker_noise']">
      <admst:assert test="[count(arguments)=2 or count(arguments)=3]"
        format="%(name): should have two or three arguments\n"/>
      <admst:choose>
        <admst:when test="[$chk_purity='yes']">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arguments[2]" match="ddx"/>
          <admst:variable name="fe" value="$e"/>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <admst:when test="[name='floor']">
      <admst:assert test="arguments[count(.)=1]"
        format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="floor($e)"/>
    </admst:when>

    <admst:when test="[name='\$fopen']">
      <admst:assert test="arguments[count(.)=1]"
        format="%(name): should have one argument exactly\n"/>
      <admst:variable name="arg1" select="%(arguments[1])"/>
      <admst:variable name="e" select="DVO.fopen($arg1)"/>
    </admst:when>

    <admst:when test="[name='\$given' or name='\$param_given']">
      <admst:variable name="arg1" select="%(arguments[1])"/>
      <admst:assert test="$arg1/adms[datatypename='variable']"
        format="\$given: argument is not a variable\n"/>
      <admst:assert test="$arg1/[input='yes']"
        format="\$given(%(name)): argument is not a parameter\n"/>
      <admst:choose>
        <admst:when test="$arg1/[parametertype='model']">
          <admst:variable name="e" select="model->$(arg1)_Given"/>
        </admst:when>
        <admst:when test="$arg1/[parametertype='instance']">
          <admst:variable name="e" select="inst->$(arg1)_Given"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal
  format="function: argument of %(name) not a model/instance parameter.\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <admst:when test="[name='idt']">
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e"
        select="ckt->va_idt(inst->STATE_idt_%(unique_id),$args)"/>
    </admst:when>

    <!--
      If there is an instance parameter named "m", $mfactor will
      expand to inst->m.  Otherwise, it will be 1.0.
    -->
    <admst:when test="[name='\$mfactor']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="m" value="1.0"/>
      <admst:for-each select="/module/variable[name='m']">
        <admst:if test="[parametertype='instance' and input='yes']">
          <admst:variable name="m" value="inst->m"/>
        </admst:if>
      </admst:for-each>
      <admst:variable name="e" select="$m"/>
    </admst:when>

    <admst:when test="[name='\$model']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="(const char*)model->GENmodName"/>
    </admst:when>

    <admst:when test="[name='\$nominal_temperature']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="ckt->CKTcurTask->TSKnomTemp"/>
    </admst:when>

    <admst:when test="[name='\$instance']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="e"
        select="(inst ? (const char*)inst->GENname : &quot;???&quot;)"/>
    </admst:when>

    <admst:when test="[name='\$port_connected']">
      <admst:assert test="arguments[count(.)=1]"
        format="%(name): should have one argument exactly\n"/>
      <admst:variable name="arg1" select="%(arguments[1])"/>
      <admst:variable name="e" select="inst->$(arg1)_Node_connected"/>
    </admst:when>

    <admst:when test="[name='\$random']">
      <admst:assert test="[count(arguments)=0 or count(arguments)=1]"
        format="%(name): should have 0 or 1 argument\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="ckt->va_random($args)"/>
    </admst:when>

    <!--
      The following random distribution functions have an extra
      argument to pass the time-lattice spacing for use duriing
      transient analysis.  If not given, the time lattice defaults to
      the transient time step.  This is WRspice-specific.
    -->

    <admst:when test="[name='\$rdist_uniform']">
      <admst:assert test="[count(arguments)=3 or count(arguments)=4]"
        format="%(name): should have 3 or 4 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_uniform($args,0.0,inst->STATE_uniform_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=4]">
        <admst:variable name="e" select="ckt->va_rdist_uniform($args,inst->STATE_uniform_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$rdist_normal']">
      <admst:assert test="[count(arguments)=3 or count(arguments)=4]"
        format="%(name): should have 3 or 4 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_normal($args,0.0,inst->STATE_normal_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=4]">
        <admst:variable name="e" select="ckt->va_rdist_normal($args,inst->STATE_normal_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$rdist_exponential']">
      <admst:assert test="[count(arguments)=2 or count(arguments)=3]"
        format="%(name): should have 2 or 3 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=2]">
        <admst:variable name="e" select="ckt->va_rdist_exponential($args,0.0,inst->STATE_exponential_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_exponential($args,inst->STATE_exponential_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$rdist_poisson']">
      <admst:assert test="[count(arguments)=2 or count(arguments)=3]"
        format="%(name): should have 2 or 3 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=2]">
        <admst:variable name="e" select="ckt->va_rdist_poisson($args,0.0,inst->STATE_poisson_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_poisson($args,inst->STATE_poisson_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$rdist_chi_square']">
      <admst:assert test="[count(arguments)=2 or count(arguments)=3]"
        format="%(name): should have 2 or 3 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=2]">
        <admst:variable name="e" select="ckt->va_rdist_chi_square($args,0.0,inst->STATE_chi_square_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_chi_square($args,inst->STATE_chi_square_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$rdist_t']">
      <admst:assert test="[count(arguments)=2 or count(arguments)=3]"
        format="%(name): should have 2 or 3 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=2]">
        <admst:variable name="e" select="ckt->va_rdist_t($args,0.0,inst->STATE_t_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_t($args,inst->STATE_t_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$rdist_erlang']">
      <admst:assert test="[count(arguments)=3 or count(arguments)=4]"
        format="%(name): should have 3 or 4 arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=3]">
        <admst:variable name="e" select="ckt->va_rdist_erlang($args,0.0,inst->STATE_erlang_%(unique_id))"/>
      </admst:if>
      <admst:if test="[count(arguments)=4]">
        <admst:variable name="e" select="ckt->va_rdist_erlang($args,inst->STATE_erlang_%(unique_id))"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$scale']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="1.0"/>
    </admst:when>

    <admst:when test="[name='\$simparam']">
      <admst:assert test="[count(arguments)=1 or count(arguments)=2]"
        format="%(name): should have one or two arguments\n"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:if test="[count(arguments)=1]">
        <admst:variable name="e" value="ckt->va_simparam($args, 0.0, false, inst)"/>
      </admst:if>
      <admst:if test="[count(arguments)=2]">
        <admst:variable name="e" value="ckt->va_simparam($args, true, inst)"/>
      </admst:if>
    </admst:when>

    <admst:when test="[name='\$temperature']">
      <admst:assert test="[nilled(arguments)]"
        format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="ckt->CKTcurTask->TSKtemp"/>
    </admst:when>

    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="e" select="(wrsCONSTKoverQ*ckt->CKTcurTask->TSKtemp)"/>   
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" select="$e"/>
          <admst:variable name="xp" select="$ep"/>
          <admst:variable name="xq" select="$eq"/>
          <admst:variable name="xpq" select="$epq"/>
          <admst:variable name="e" select="wrsCONSTKoverQ*$x"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   

    <admst:when test="[name='white_noise']">
      <admst:assert test="[count(arguments)=1 or count(arguments)=2]"
        format="%(name): should have one or two arguments\n"/>
      <admst:choose>
        <admst:when test="[$chk_purity='yes']">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>

    <admst:when test="[$SkipProbe='yes']">
      <admst:variable name="fname" select="%(funcname(.)/value)"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="$fname($args)"/>
    </admst:when>

    <admst:when test="[math:isfunc:1(.)/value='yes']">
      <admst:assert test="arguments[count(.)=1]"
        format="%(name): should have one argument exactly\n"/>
      <admst:variable name="index"
        select="%(index(subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/value)"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:variable name="e" select="f_$fname$index.val"/>
    </admst:when>

    <admst:when test="[math:isfunc:2(.)/value='yes']">
      <admst:assert test="arguments[count(.)=2]"
        format="%(name): should have two argument exactly\n"/>
      <admst:variable name="index"
        select="%(index(./subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/value)"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" select="$e"/>
      <admst:variable name="yp" select="$ep"/>
      <admst:variable name="yq" select="$eq"/>
      <admst:variable name="ypq" select="$epq"/>
      <admst:variable name="e" select="f_$fname$index.val"/>
    </admst:when>

    <admst:otherwise>
      <!-- Must be a call to an analog function. -->
      <admst:variable name="fname" select="%(funcname(.)/value)"/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
          <admst:variable name="pargs" select="$pargs,"/>
          <admst:variable name="qargs" select="$qargs,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
        <admst:variable name="pargs" select="$pargs$ep"/>
        <admst:variable name="qargs" select="$qargs$eq"/>
      </admst:for-each>
      <admst:variable name="e" select="$fname($args)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:choose>
    <admst:when test="[$SkipProbe='yes']"/>

    <admst:when test="[name='ddt']">
      <admst:variable name="ep" select="$xp"/>
      <!-- OBSOLETE
      <admst:choose>
        <admst:when test="[$DDTFUNC='twopass' and $loadpass2='no']"/>
        <admst:otherwise>
          <admst:variable name="ep" select="$xp"/>
        </admst:otherwise>
      </admst:choose>
      -->
    </admst:when>

    <admst:when test="[name='ddx']">
      <admst:variable name="arg1" path="arguments[1]"/>
      <admst:variable name="ddxprobe" path="arguments[2]"/>
      <admst:variable name="tpp" path="$pprobe"/>
      <admst:variable name="tpq" path="$qprobe"/>
      <admst:variable name="allepq" value="0.0"/>
      <admst:variable name="qprobe" path="$pprobe"/>
      <admst:variable name="etmp" value="$e"/>
      <!-- We know from above that $arg1 is a variable, not an expression. -->
      <admst:for-each select="$arg1/probe">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:choose>
          <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$arg1" match="ddx"/>
            <admst:variable name="leftval" value="$allepq"/>
            <admst:variable name="rightval" value="$epq"/>
            <admst:apply-templates select="." match="math:add"/>
            <admst:variable name="allepq" value="$leftval"/>
          </admst:when>
          <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$arg1" match="ddx"/>
            <admst:variable name="leftval" value="$allepq"/>
            <admst:variable name="rightval" value="$epq"/>
            <admst:apply-templates select="." match="math:sub"/>
            <admst:variable name="allepq" value="$leftval"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:variable name="leftval" value="$allepq"/>
      <admst:apply-templates select="." match="math:emparen"/>
      <admst:variable name="ep" value="$leftval"/>
      <admst:variable name="pprobe" path="$tpp"/>
      <admst:variable name="qprobe" path="$tpq"/>
      <admst:variable name="e" value="$etmp"/>
    </admst:when>

    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="ep" select="wrsCONSTKoverQ*$xp"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   

    <admst:when test="[math:isfunc:1(.)/value='yes']">
      <!-- ep = f_$fname$index.dx*$xp -->
      <admst:variable name="index"
        select="%(index(subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/value)"/>

      <admst:variable name="leftval" value="f_$fname$index.dx"/>
      <admst:variable name="rightval" value="$xp"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="ep" select="$leftval"/>
    </admst:when>

    <admst:when test="[math:isfunc:2(.)/value='yes']">
      <!-- ep = (f_$fname$index.dx*$xp + f_$fname$index.dy*$yp) -->
      <admst:variable name="index"
        select="%(index(./subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/value)"/>

      <admst:variable name="leftval" value="f_$fname$index.dx"/>
      <admst:variable name="rightval" value="$xp"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="ep" select="$leftval"/>
      <admst:variable name="leftval" value="f_$fname$index.dy"/>
      <admst:variable name="rightval" value="$yp"/>
      <admst:apply-templates select="." match="math:mult"/>
      <admst:variable name="rightval" value="$leftval"/>
      <admst:variable name="leftval" value="$ep"/>
      <admst:apply-templates select="." match="math:add:emparen"/>
      <admst:variable name="ep" select="$leftval"/>
    </admst:when>

    <admst:when test="[exists(definition)]">
      <!-- analog function -->
      <admst:variable name="fname" select="%(funcname(.)/value)"/>
      <admst:variable name="ep" select="d_$fname($args,$pargs)"/>
    </admst:when>
  </admst:choose>

  <admst:variable name="eq" select="0.0"/>
  <admst:variable name="epq" select="0.0"/>
  <admst:if test="$qprobe">
    <admst:choose>
      <admst:when test="[$SkipProbe='yes']"/>

      <admst:when test="[name='ddt']">
        <admst:variable name="eq" select="$xq"/>
        <!-- OBSOLETE
        <admst:choose>
          <admst:when test="[$DDTFUNC='twopass' and $loadpass2='no']"/>
          <admst:otherwise>
            <admst:variable name="eq" select="$xq"/>
          </admst:otherwise>
        </admst:choose>
        -->
      </admst:when>

      <admst:when test="[name='\$vt']">
        <admst:choose>
          <admst:when test="[nilled(arguments)]">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="arguments[count(.)=1]">
            <admst:variable name="eq" select="wrsCONSTKoverQ*$xq"/>   
          </admst:when>
        </admst:choose>
      </admst:when>   

      <admst:when test="[math:isfunc:1(.)/value='yes']">
        <!-- eq = f_$fname$index.dx*$xq -->
        <admst:variable name="index"
          select="%(index(subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="eq" select="$leftval"/>
      </admst:when>

      <admst:when test="[math:isfunc:2(.)/value='yes']">
        <!-- eq = (f_$fname$index.dx*$xq + f_$fname$index.dy*$yq) -->
        <admst:variable name="index"
          select="%(index(./subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="eq" select="$leftval"/>
        <admst:variable name="leftval" value="f_$fname$index.dy"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$eq"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="eq" select="$leftval"/>
      </admst:when>

      <admst:when test="[exists(definition)]">
        <!-- analog function -->
        <admst:variable name="fname" select="%(funcname(.)/value)"/>
        <admst:variable name="eq" select="d_$fname($args,$qargs)"/>
      </admst:when>
    </admst:choose>

    <admst:choose>
      <admst:when test="[$SkipProbe='yes']"/>

      <admst:when test="[name='ddt']">
        <admst:variable name="epq" select="$xpq"/>
        <!-- OBSOLETE
        <admst:choose>
          <admst:when test="[$DDTFUNC='twopass' and $loadpass2='no']"/>
          <admst:otherwise>
            <admst:variable name="epq" select="$xpq"/>
          </admst:otherwise>
        </admst:choose>
        -->
      </admst:when>

      <admst:when test="[math:isfunc:1(.)/value='yes']">
        <!-- epq = f_$fname$index.dxx*$xq*$xp + f_$fname$index.dx*$xpq -->
        <admst:variable name="index"
          select="%(index(./subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="f_$fname$index.dxx"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$xp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="epq" select="$leftval"/>
        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xpq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>

      <admst:when test="[name='add' or name='min' or name='max']">
        <!-- These have no second derivative terms. -->
        <!-- epq = f_$fname$index.dx*$xpq + f_$fname$index.dy*$ypq -->
        <admst:variable name="index"
          select="%(index(./subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xpq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="epq" select="$leftval"/>
        <admst:variable name="leftval" value="f_$fname$index.dy"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>

      <admst:when test="[name='mult']">
        <!-- dxx=0, dxy=1, dyy=0 -->
        <!-- epq = $xp*$yq + $yp*$xq + f_$fname$index.dx*$xpq +
                   f_$fname$index.dy*$ypq -->
        <admst:variable name="index"
          select="%(index(./subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="$xp"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="epq" value="$leftval"/>

        <admst:variable name="leftval" value="$yp"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xpq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dy"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:apply-templates select="." match="math:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>

      <admst:when test="[name='div']">
        <!-- dxx=0 -->
        <!-- epq = f_$fname$index.dxy*($xp*$yq + $yp*$xq) +
                   f_$fname$index.dyy*$yp*$yq +
                   f_$fname$index.dx*$xpq +
                   f_$fname$index.dy*$ypq -->
        <admst:variable name="index"
          select="%(index(./subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="$yp"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="tmpval" value="$leftval"/>
        <admst:variable name="leftval" value="$xp"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$tmpval"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="f_$fname$index.dxy"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dyy"/>
        <admst:variable name="rightval" value="$yp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xpq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dy"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:apply-templates select="." match="math:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>

      <admst:when test="[name='atan2' or name='pow' or name='hypot']">
        <!-- epq = f_$fname$index.dxx*$xp*$xq +
                   f_$fname$index.dxy*($xp*$yq + $yp*$xq) +
                   f_$fname$index.dyy*$yp*$yq +
                   f_$fname$index.dx*$xpq +
                   f_$fname$index.dy*$ypq -->
        <admst:variable name="index"
          select="%(index(./subexpression/expression/function,.))"/>
        <admst:variable name="fname" select="%(funcname(.)/value)"/>

        <admst:variable name="leftval" value="f_$fname$index.dxx"/>
        <admst:variable name="rightval" value="$xp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="epq" value="$leftval"/>

        <admst:variable name="leftval" value="$yp"/>
        <admst:variable name="rightval" value="$xq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="tmpval" value="$leftval"/>
        <admst:variable name="leftval" value="$xp"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$tmpval"/>
        <admst:apply-templates select="." match="math:add:emparen"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="f_$fname$index.dxy"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dyy"/>
        <admst:variable name="rightval" value="$yp"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$yq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dx"/>
        <admst:variable name="rightval" value="$xpq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:variable name="epq" select="$leftval"/>

        <admst:variable name="leftval" value="f_$fname$index.dy"/>
        <admst:variable name="rightval" value="$ypq"/>
        <admst:apply-templates select="." match="math:mult"/>
        <admst:variable name="rightval" value="$leftval"/>
        <admst:variable name="leftval" value="$epq"/>
        <admst:apply-templates select="." match="math:add"/>
        <admst:apply-templates select="." match="math:emparen"/>
        <admst:variable name="epq" select="$leftval"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Search through everything for function calls.  We don't use the
  expression/function lists, since not all "functions" are included
  in these lists.  For example, adms-2.3.0 does not put idt in the
  lists.

  For each function, a template named in $findfunc_dofunc is called.
  The user must implement this, and set the variable.  If $findfunc_asonly
  is 'yes', only functions that appear in the rhs of assignments will
  be considered.  The $findfunc_inas variable is used internally.
-->
<admst:variable name="findfunc_dofunc" value="dofunc"/>
<admst:variable name="findfunc_asonly" value="no"/>
<admst:variable name="findfunc_inas" value="no"/>

<admst:template match="findfunc">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:variable name="findfunc_inas" value="yes"/>
      <admst:apply-templates select="rhs" match="findfunc"/>
      <admst:variable name="findfunc_inas" value="no"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="findfunc"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="findfunc"/>
      <admst:apply-templates select="then" match="findfunc"/>
      <admst:apply-templates select="else" match="findfunc"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="findfunc"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:apply-templates select="." match="findfunc"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="findfunc"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="findfunc"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="forblock" match="findfunc"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:if test="[$findfunc_asonly='no']">
       <admst:apply-templates select="rhs" match="findfunc"/>
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:apply-templates select="function" match="findfunc"/>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:when test="adms[datatypename='node']"/>
    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="findfunc"/>
    </admst:when>
    <admst:when test="[datatypename='probe']"/>
    <admst:when test="[datatypename='array']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="findfunc"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="findfunc"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="findfunc"/>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:apply-templates select="arguments" match="findfunc"/>
      <admst:if test="[$findfunc_asonly='no' or $findfunc_inas='yes']">
        <admst:apply-templates select="." match="$findfunc_dofunc"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:otherwise>
      <admst:warning format="findfunc: unhandled type %(datatypename).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Return yes if any ./function is a differentiable math function.  We
  start a block in this case.
-->
<admst:template match="function:ddxblock">
  <admst:variable name="ddxblk" value="no"/>
  <admst:for-each select="function">
    <admst:if test="[math:isfunc:1(.)/value='yes' or
        math:isfunc:2(.)/value='yes']">
      <admst:variable name="ddxblk" value="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:return name="ddxblk" value="$ddxblk"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="function:precomputation">
  <admst:variable name="index" select="%(index(../function,.))"/>
  <admst:variable name="fname" select="%(funcname(.)/value)"/>
  <admst:choose>
    <admst:when test="[math:isfunc:1(.)/value='yes']">
      <admst:if test="arguments[1]/[datatypename='mapply_binary']">
        <admst:variable name="noparens" value="yes"/>
      </admst:if>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="arg1" value="$e"/>
      <admst:text
        format="$(indent)mfunc_$(fname)_t f_$fname$index($arg1);\n"/>
      <admst:if test="[$fname='limexp']">
        <admst:text format="$(indent){\n"/>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:text format="$(indent)double val = f_$fname$index.arg;\n"/>
        <admst:text format="$(indent)if (ckt->CKTstat->STATnumIter > 1) {\n"/>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:text format="$(indent)int plimit;\n"/>
        <admst:text
  format="$(indent)val = DEV.limexp(val,inst->limexp_value%(unique_id),&plimit);\n"/>
        <admst:text format="$(indent)if (plimit)\n"/>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:text format="$(indent)ckt->CKTnoncon++;\n"/>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)inst->limexp_value%(unique_id) = val;\n"/>
        <admst:text format="$(indent)f_$fname$index.val = exp(val);\n"/>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)}\n"/>
        <admst:text format="$(indent)else {\n"/>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:text format="$(indent)if (val > 80.0) {\n"/>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:text format="$(indent)f_$fname$index.val = exp(80.0);\n"/>
        <admst:text format="$(indent)f_$fname$index.val *= (1.0+(val-80.0));\n"/>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)}\n"/>
        <admst:text format="$(indent)else {\n"/>
        <admst:apply-templates select="." match="push_indent"/>
        <admst:text format="$(indent)f_$fname$index.val = exp(val);\n"/>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)}\n"/>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)}\n"/>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)}\n"/>
      </admst:if>
    </admst:when>
    <admst:when test="[math:isfunc:2(.)/value='yes']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="arg1" value="$e"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="arg2" value="$e"/>
      <admst:text
        format="$(indent)mfunc2_$(fname)_t f_$fname$index($arg1,$arg2);\n"/>
    </admst:when>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="function:derivate:precomputation">
  <admst:if test="[hasVoltageDependentFunction='yes']">
    <admst:if test="[$emit_defines='yes']">
      <admst:choose>
        <admst:when test="[$ddxinsidederivate='yes']">
          <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text  format="#if defined(_DERIVATE)\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
    <admst:for-each select="function">
      <admst:variable name="index" select="%(index(../function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/value)"/>
      <admst:choose>
        <admst:when test="[math:isfunc:1(.)/value='yes']">
          <admst:if test="arguments[1]/math[dependency!='constant']">
            <admst:text
              format="$(indent)f_$fname$index.d_$fname();\n"/>
          </admst:if>
        </admst:when>
        <admst:when test="[math:isfunc:2(.)/value='yes']">
          <admst:choose>
            <admst:when test="[arguments[1]/math/dependency!='constant' and
                arguments[2]/math/dependency!='constant']">
              <admst:text
                format="$(indent)f_$fname$index.dyy_$fname();\n"/>
            </admst:when>
            <admst:when test="arguments[2]/math[dependency='constant']">
              <admst:text
                format="$(indent)f_$fname$index.dyn_$fname();\n"/>
            </admst:when>
            <admst:when test="arguments[1]/math[dependency='constant']">
              <admst:text
                format="$(indent)f_$fname$index.dny_$fname();\n"/>
            </admst:when>
          </admst:choose>
        </admst:when>
      </admst:choose>
    </admst:for-each>
    <admst:if test="[$emit_defines='yes']">
      <admst:choose>
        <admst:when test="[$ddxinsidederivate='yes']">
          <admst:text format="#endif // _DERIVATEFORDDX\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="#endif // _DERIVATE\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$fclose']">
      <admst:text format="$(indent)DVO.fclose("/>
    </admst:when>
    <admst:when test="function[name='\$display']">
      <admst:text format="$(indent)DVO.display(model,inst,"/>
    </admst:when>
    <admst:when test="function[name='\$fdisplay']">
      <admst:text format="$(indent)DVO.fdisplay(model,inst,"/>
    </admst:when>
    <admst:when test="function[name='\$write']">
      <admst:text format="$(indent)DVO.write(model,inst,"/>
    </admst:when>
    <admst:when test="function[name='\$fwrite']">
      <admst:text format="$(indent)DVO.fwrite(model,inst,"/>
    </admst:when>
    <admst:when test="function[name='\$monitor']">
      <admst:text format="$(indent)DVO.monitor(model,inst,%(function/unique_id),"/>
    </admst:when>
    <admst:when test="function[name='\$fmonitor']">
      <admst:text format="$(indent)DVO.fmonitor(model,inst,%(function/unique_id),"/>
    </admst:when>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="$(indent)DVO.strobe(model,inst,%(function/unique_id),"/>
    </admst:when>
    <admst:when test="function[name='\$fstrobe']">
      <admst:text format="$(indent)DVO.fstrobe(model,inst,%(function/unique_id),"/>
    </admst:when>
    <admst:when test="function[name='\$warning']">
      <admst:text format="$(indent)DVO.warning(model,inst,"/>
    </admst:when>
    <admst:when test="function[name='\$error']">
      <admst:text format="$(indent)DVO.error(model,inst,"/>
    </admst:when>
    <admst:when test="function[name='\$finish']">
      <admst:text format="$(indent)return DVO.finish(model,inst,ckt->CKTtime,"/>
    </admst:when>
    <admst:when test="function[name='\$stop']">
      <admst:text format="$(indent)return DVO.stop(model,inst,ckt->CKTtime,"/>
    </admst:when>
    <admst:when test="function[name='\$bound_step']">
      <admst:text format="$(indent)ckt->va_boundStep("/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal
        format="callfunction: unsupported function %(function/name).\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:join select="function/arguments" separator=",">
    <admst:text format="%(e(tree))"/>
  </admst:join>
  <admst:text format=");\n"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="block">
  <!--
    The nobrackets global is used only to suppress the block brackets
    when they would be redundant.  The only real effect is to provide
    inline opening brackets, e.g.
      if (something) {
          block elements
      }
    instead of
      if (something)
      {
          block elements
      }
    The latter form can be set if one omits the brackets in the
    parent if/for/etc, and never sets nobrackets to yes.
  -->

  <admst:variable name="brbak" value="$nobrackets"/>
  <admst:if test="[$brbak!='yes']">
    <admst:text format="$(indent){\n"/>
    <admst:apply-templates select="." match="push_indent"/>
  </admst:if>
  <admst:variable name="nobrackets" value="no"/>
  <admst:if test="variable">
    <admst:text format="$(indent)// blockname=%(name)\n"/>
    <admst:for-each select="variable">
      <admst:apply-templates select="." match="variable:declaration"/>
    </admst:for-each>
  </admst:if>
  <admst:apply-templates select="item" match="%(adms/datatypename)"/>
  <admst:if test="[$brbak!='yes']">
    <admst:apply-templates select="." match="pop_indent"/>
    <admst:text format="$(indent)}\n"/>
  </admst:if>
  <admst:variable name="nobrackets" value="$brbak"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="blockvariable">
  <admst:text select="variable" format="$(indent)%(vtype(.)) %(name);\n"/>
  <admst:if test="variable[insource='yes']/probe">
    <admst:if test="[$SkipProbe='no']">
      <admst:for-each select="variable">
        <admst:variable name="myvar" select="%(.)"/>

        <admst:for-each select="probe">
            <admst:variable name="pprobe" select="%(.)"/>
            <admst:variable name="ddxinsidethisprobe" select="no"/>
            <admst:if
  test="$myvar/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
  .=$pprobe/branch/nnode]">
              <admst:variable name="ddxinsidethisprobe" select="yes"/>
            </admst:if>
            <admst:if test="[$emit_defines='yes']">
              <admst:text test="[$ddxinsidethisprobe='yes']"
                format="#if defined(_DERIVATEFORDDX)\n"/>
              <admst:text test="[$ddxinsidethisprobe='no']"
                format="#if defined(_DERIVATE)\n"/>
            </admst:if>
            <admst:text
  format="$(indent)double %(dxname($myvar)/[name='dxname']/value);\n"/>
            <admst:if test="[$emit_defines='yes']">
              <admst:text test="[$ddxinsidethisprobe='yes']"
                format="#endif // _DERIVATEFORDDX\n"/>
              <admst:text test="[$ddxinsidethisprobe='no']"
                format="#endif // _DERIVATE\n"/>
            </admst:if>
        </admst:for-each>
      </admst:for-each>

      <admst:for-each select="variable">
        <admst:variable name="myvar" select="%(.)"/>
        <admst:new datatype="list" arguments="list of ddx probes">
          <admst:variable name="ddxprobes" select="%(.)"/>
          <admst:for-each select="$myvar/probe">
            <admst:variable name="pprobe" select="%(.)"/>
            <admst:push into="$ddxprobes/item"
  select="$myvar/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
  .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
          </admst:for-each>
        </admst:new>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="$ddxprobes/item"
            format="#if defined(_DERIVATE)\n"/>
        </admst:if>
        <admst:for-each select="$ddxprobes/item">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:for-each select="$myvar/probe">
            <admst:variable name="qprobe" select="%(.)"/>
            <admst:text
  format="$(indent)double %(ddxname($myvar)/[name='ddxname']/value);\n"/>
          </admst:for-each>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="$ddxprobes/item" format="#endif // _DERIVATE\n"/>
        </admst:if>
      </admst:for-each>

    </admst:if>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="assignment">
  <admst:variable name="a_ddxblk" value="no"/>
  <admst:if test="[$emit_defines='yes']">
    <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  </admst:if>
  <!--
    It would be nice to put the "ddxblk" assignments in blocks as part
    of the initialization rather than adding brackets here. 
    Unfortunately, this does not seem possible, as attempts to use
    admst:value-to to replace a random element of a block list failed.
  -->

  <admst:if test="[$SkipProbe='no']">
    <admst:if test="rhs/function">
      <admst:variable name="a_ddxblk" value="%(function:ddxblock(rhs)/value)"/>
      <admst:if test="[$a_ddxblk='yes']">
        <admst:if test="[$nobrackets!='yes']">
          <admst:text format="$(indent){\n"/>
          <admst:apply-templates select="." match="push_indent"/>
        </admst:if>
        <admst:apply-templates select="rhs/function"
          match="function:precomputation"/>
      </admst:if>
    </admst:if>
    <!-- array support 111017 -->
    <admst:if test="[lhs/datatypename='array']">
      <admst:variable name="lhs" select="%(lhs/variable)"/>
    </admst:if>
    <admst:if test="[lhs/datatypename='variable']">
      <admst:variable name="lhs" select="%(lhs)"/>
    </admst:if>
    <admst:for-each select="$lhs/probe">
      <admst:variable name="pprobe" select="%(.)"/>
      <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
          .=$pprobe/branch/nnode]">
        <admst:variable name="ddxinsidederivate" select="yes"/>
      </admst:if>
    </admst:for-each>
    <admst:if test="$lhs[insource='yes']">
      <admst:apply-templates select="rhs[not(nilled(function))]"
        match="function:derivate:precomputation"/>
    </admst:if>
  </admst:if>

  <admst:if test="[$SkipProbe='no']">
    <admst:variable name="rhs" select="%(rhs)"/>
    <!-- array support 111017 -->
    <admst:variable name="isarray" select="no"/>
    <admst:variable name="subscr" select=""/>
    <admst:if test="[lhs/datatypename='array']">
      <admst:variable name="tn" value="%(lhs/index/datatypename)"/>
      <admst:apply-templates select="lhs/index" match="$tn"/>
      <admst:variable name="leftval" value="$e"/>
      <admst:apply-templates select="lhs/variable" match="math:ixval"/>
      <admst:variable name="subscr" select="$leftval"/>
      <admst:variable name="isarray" select="yes"/>
    </admst:if>
    <admst:if test="[lhs/datatypename='variable']">
      <admst:variable name="lhs" select="%(lhs)"/>
    </admst:if>

    <admst:if test="$lhs[insource='yes']">
      <admst:if test="[$emit_defines='yes']">
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
            <admst:text
  format="$(indent)// probe=%($lhs/probe) ddxprobe=%($lhs/ddxprobe)\n"/>
          </admst:when>
          <admst:when test="$lhs/probe">
            <admst:text format="#if defined(_DERIVATE)\n"/>
            <admst:text
  format="$(indent)// probe=%($lhs/probe) ddxprobe=%($lhs/ddxprobe)\n"/>
          </admst:when>
        </admst:choose>
      </admst:if>

      <admst:for-each select="$lhs/probe">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:variable name="ddxinsidethisprobe" select="no"/>
        <admst:if test="$lhs/ddxprobe/branch/pnode[
            .=$pprobe/branch/pnode or
            .=$pprobe/branch/nnode]">
          <admst:variable name="ddxinsidethisprobe" select="yes"/>
        </admst:if>
        <admst:variable name="isinside" select="0"/>
        <admst:if test="$rhs/probe[.=$pprobe]">
          <admst:variable name="isinside" select="1"/>
        </admst:if>
        <admst:variable name="qprobe"/>
        <admst:variable name="ep" select="0.0"/>
        <admst:apply-templates select="[$isinside='1']/$rhs/tree"
          match="ddx"/>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidederivate='yes' and
            $ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
        </admst:if>
        <admst:variable name="v" path="dxname($lhs)/[name='dxname']/value"/>
        <admst:if test="[$v!=$ep]">
            <admst:if test="[$isarray='yes']">
              <admst:text format="$(indent)%($v)[$subscr] = $ep;\n"/>
            </admst:if>
            <admst:if test="[$isarray='no']">
              <admst:text format="$(indent)%($v) = $ep;\n"/>
            </admst:if>
          <!-- FPE TEST
          <admst:apply-templates select="$v" match="checkval"/>
          -->
        </admst:if>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidederivate='yes' and
            $ddxinsidethisprobe='no']" format="#endif // _DERIVATE\n"/>
        </admst:if>

        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidethisprobe='yes']"
            format="#if defined(_DERIVATE2)\n"/>
        </admst:if>
        <admst:for-each select="$lhs[$ddxinsidethisprobe='yes']/probe">
          <admst:variable name="epq" select="0.0"/>
          <admst:variable name="qprobe" select="%(.)"/>
          <admst:apply-templates select="[$isinside='1']/$rhs/tree"
            match="ddx"/>
          <admst:variable name="v" path="ddxname($lhs)/[name='ddxname']/value"/>
          <admst:if test="[$v!=$epq]">
            <admst:if test="[$isarray='yes']">
              <admst:text format="$(indent)%($v)[$subscr] = $epq;\n"/>
            </admst:if>
            <admst:if test="[$isarray='no']">
                <admst:text format="$(indent)%($v) = $epq;\n"/>
            </admst:if>
            <!-- FPE TEST
            <admst:apply-templates select="$v" match="checkval"/>
            -->
          </admst:if>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
            <admst:text test="[$ddxinsidethisprobe='yes']"
              format="#endif // _DERIVATE2\n"/>
        </admst:if>
      </admst:for-each>

      <admst:if test="[$emit_defines='yes']">
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#endif // _DERIVATEFORDDX\n"/>
          </admst:when>
          <admst:when test="lhs/probe">
            <admst:text format="#endif // _DERIVATE\n"/>
          </admst:when>
        </admst:choose>
      </admst:if>
      <admst:variable name="ddxinsidederivate" select="no"/>
    </admst:if>
  </admst:if>

  <admst:apply-templates select="lhs" match="%(datatypename)"/>
  <admst:variable name="v" value="$e"/>
  <admst:text format="$(indent)$e = %(e(rhs/tree));\n"/>
  <!-- FPE TEST
  <admst:apply-templates select="$v" match="checkval"/>
  -->

  <admst:if test="[$a_ddxblk='yes']">
    <admst:if test="[$nobrackets!='yes']">
      <admst:apply-templates select="." match="pop_indent"/>
      <admst:text format="$(indent)}\n"/>
    </admst:if>
  </admst:if>
  <admst:if test="[$emit_defines='yes']">
    <admst:text test="[dynamic='yes']" format="#endif // _DYNAMIC\n"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!-- FPE TEST
<admst:template match="checkval">
  <admst:text format="if (isnan(%(.)) || isinf(%(.)) || fabs(%(.)) > 1e120) {DVO.textOut(OUT_WARNING, &quot;line=%%d %(.) = %%g&quot;, __LINE__, %(.)); return (E_PANIC); }\n"/>
  <admst:text format="if (ckt->checkFPE(false)) DVO.textOut(OUT_WARNING, &quot;line=%%d %(.)=%%g&quot;, ))LINE__, %(.));\n"/>
  <admst:text format="$(indent)EXIT_IF_ISNAN(%(.))\n"/>
</admst:template>
-->

<!-- ---------------------------------------------------------------------- -->
<admst:template match="contribution">
  <admst:choose>
    <admst:when test="[whitenoise='yes' or flickernoise='yes']">
      <admst:variable name="tmpsp" value="$SkipProbe"/>
      <admst:variable name="SkipProbe" select="yes"/>
      <admst:variable name="dependency" select="%(math/dependency)"/>
      <admst:if test="[whitenoise='yes']">
        <admst:if test="[$dependency='constant']">
          <admst:text
            format="$(indent)inst->tnoise%(index($tnoise/item,.))="/>
        </admst:if>
        <admst:if test="[$dependency!='constant']">
          <admst:text
            format="$(indent)inst->wnoise%(index($wnoise/item,.))="/>
        </admst:if>
        <admst:apply-templates select="rhs/tree" match="ddx"/>
        <admst:text format="$e;\n"/>
      </admst:if>
      <admst:if test="[flickernoise='yes']">
        <admst:text
          format="$(indent)inst->fpnoise%(index($fnoise/item,.))="/>
        <admst:apply-templates select="rhs/tree" match="ddx"/>
        <admst:text format="$e;\n"/>
        <admst:text
          format="$(indent)inst->fenoise%(index($fnoise/item,.))="/>
        <admst:text format="$fe;\n"/>
      </admst:if>
      <admst:variable name="SkipProbe" select="$tmpsp"/>
      <!-- OBSOLETE
      <admst:if test="[$loadpass2='no']">
      -->
        <admst:variable name="tmpsp" value="$SkipProbe"/>
        <admst:variable name="SkipProbe" select="yes"/>
        <admst:variable name="dependency" select="%(math/dependency)"/>
        <admst:if test="[whitenoise='yes']">
          <admst:if test="[$dependency='constant']">
            <admst:text
              format="$(indent)inst->tnoise%(index($tnoise/item,.))="/>
          </admst:if>
          <admst:if test="[$dependency!='constant']">
            <admst:text
              format="$(indent)inst->wnoise%(index($wnoise/item,.))="/>
          </admst:if>
          <admst:apply-templates select="rhs/tree" match="ddx"/>
          <admst:text format="$e;\n"/>
        </admst:if>
        <admst:if test="[flickernoise='yes']">
          <admst:text
            format="$(indent)inst->fpnoise%(index($fnoise/item,.))="/>
          <admst:apply-templates select="rhs/tree" match="ddx"/>
          <admst:text format="$e;\n"/>
          <admst:text
            format="$(indent)inst->fenoise%(index($fnoise/item,.))="/>
          <admst:text format="$fe;\n"/>
        </admst:if>
        <admst:variable name="SkipProbe" select="$tmpsp"/>
      <!-- OBSOLETE
      </admst:if>
      -->
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:nonoise"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  This tests a contribution and returns a code indicating whether and
  how the contribution can be "collapsed".  This applies only to
  potential lhs nature when the rhs is a constant 0, indicating that a
  zero-voltage source should bridge the two nodes.  When collapsing,
  we set one node to the internal number of another.  It is more
  efficient to collapse the nodes, as this avoids allocating a branch
  element in the circuit matrix.

  Only internal and unconnected optional external nodes can be
  collapsed.

  The return codes are:

  no    can't collapse
  p0    positive node <-- 0
  pn    positive node <-- negative node
  np    negative node <-- positive node

  defer
        Defer action.  If both sides are internal or optional, we can
        still tie the nodes together in many cases.  This will happen
        during node assignment in the setup method, through calls to
        the inst->resolve_ties method produced later.

        An unconnected optional node is by default floating.  Thus, if
        it is required, an internal node will be created (as opposed
        to just setting it to ground).  An unconnected optional node
        is treated just as an internal node.
-->
<admst:template match="check_collapsed">
  <admst:variable name="srcpnode" path="lhs/branch/pnode"/>
  <admst:variable name="srcnnode" path="lhs/branch/nnode"/>
  <admst:variable name="srcpname" path="$srcpnode/name"/>
  <admst:variable name="srcnname" path="$srcnnode/name"/>
  <admst:variable name="ret" value="no"/>

  <admst:if test="[lhs/nature=lhs/discipline/potential]">
    <admst:apply-templates select="rhs/tree" match="ddx"/>
    <admst:variable name="rhs" value="$e"/>
    <admst:if test="[math:is_zero($rhs)/value='yes']">
      <admst:if test="[$srcpnode/location='internal' or
          $srcpnode/attribute[name='optional']/value='yes']">
        <admst:choose>
          <admst:when test="$srcnnode[grounded='yes']">
            <admst:variable name="ret" value="p0"/>
          </admst:when>
          <admst:when test="[$srcnnode/location='external' and
              $srcnnode/attribute[name='optional']/value='no']">
            <admst:variable name="ret" value="pn"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ret" value="defer"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:if test="[$srcnnode/location='internal' or
          $srcnnode/attribute[name='optional']/value='yes']">
        <admst:if test="[$srcpnode/location='external' and
            $srcpnode/attribute[name='optional']/value='no']">
          <admst:variable name="ret" value="np"/>
        </admst:if>
      </admst:if>
    </admst:if>
  </admst:if>
  <admst:return name="value" value="$ret"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="contribution:nonoise">
  <admst:if test="[$emit_defines='yes']">
    <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  </admst:if>
  <admst:if test="rhs/function">
    <admst:text format="$(indent){\n"/>
    <admst:apply-templates select="." match="push_indent"/>
  </admst:if>
  <admst:apply-templates select="rhs/function"
    match="function:precomputation"/>
  <admst:apply-templates select="rhs[not(nilled(function))]"
    match="function:derivate:precomputation"/>
  <admst:variable name="srcpnode" path="lhs/branch/pnode"/>
  <admst:variable name="srcnnode" path="lhs/branch/nnode"/>
  <admst:variable name="srcpname" path="$srcpnode/name"/>
  <admst:variable name="srcnname" path="$srcnnode/name"/>

  <!-- V() <+ ... -->
  <admst:if test="[lhs/nature=lhs/discipline/potential]">
    <admst:variable name="collapsed"
      value="%(attribute[name='collapsed']/value)"/>
    <admst:choose>
      <admst:when test="[$collapsed='p0']">
        <admst:text format="$(indent)// collapsed $srcpname = $srcnname\n"/>
      </admst:when>
      <admst:when test="[$collapsed='pn']">
        <admst:text format="$(indent)// collapsed $srcpname = $srcnname\n"/>
      </admst:when>
      <admst:when test="[$collapsed='np']">
        <admst:text format="$(indent)// collapsed $srcnname = $srcpname\n"/>
      </admst:when>
      <admst:when test="[$collapsed='defer']">
        <admst:text format="$(indent)// $srcpname, $srcnname collapsed\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="bname" value="$(srcpname)_$(srcnname)_Branch"/>
        <admst:choose>
          <admst:when test="$srcnnode[grounded='yes']">
            <admst:text format="$(indent)if (inst->PTR_$(bname)_P_required &amp;&amp; inst->$(srcpname)_Node > 0) {\n"/>
            <admst:apply-templates select="." match="push_indent"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="$(indent)if ((inst->PTR_$(bname)_P_required ||\n"/>
            <admst:apply-templates select="." match="push_indent"/>
            <admst:apply-templates select="." match="push_indent"/>
            <admst:text format="$(indent)inst->PTR_$(bname)_N_required) &amp;&amp;\n"/>
            <admst:text format="$(indent)inst->$(srcpname)_Node >= 0 &amp;&amp; inst->$(srcnname)_Node >= 0 &amp;&amp;\n"/>
            <admst:text format="$(indent)inst->$(srcpname)_Node != inst->$(srcnname)_Node) {\n"/>
            <admst:apply-templates select="." match="pop_indent"/>
          </admst:otherwise>
        </admst:choose>
        <admst:text format="$(indent)_load_branch_P($srcpname, $srcnname);\n"/>
        <admst:if test="$srcnnode[grounded='no']">
          <admst:text format="$(indent)_load_branch_N($srcpname, $srcnname);\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[dynamic='yes']">
            <admst:text format="$(indent)_load_branch_dynamic_"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="$(indent)_load_branch_static_"/>
          </admst:otherwise>
        </admst:choose>

        <admst:apply-templates select="rhs/tree" match="ddx"/>
        <admst:text format="residual($srcpname, $srcnname, $e);\n"/>

        <!--  ddx needs the following!  -->
        <admst:for-each select="rhs/probe">
          <admst:variable name="pprobe" path="."/>
<!-- XXX
error here?  below generates "bad attribute" erors
          <admst:apply-templates select="../rhs/tree" match="ddx"/>
-->
          <admst:apply-templates select="../tree" match="ddx"/>
          <admst:choose>
            <admst:when test="../[dynamic='yes']">
              <admst:text
  format="$(indent)_load_branch_dynamic($srcpname, $srcnname, $ep);\n"/>
            </admst:when>
            <admst:otherwise>
              <admst:text
  format="$(indent)_load_branch_static($srcpname, $srcnname, $ep);\n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:apply-templates select="." match="pop_indent"/>
        <admst:text format="$(indent)}\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>

  <!-- I() <+ ... -->
  <admst:if test="[lhs/nature=lhs/discipline/flow]">
    <admst:text format="$(indent)_load_"/>
    <admst:choose>
      <admst:when test="[dynamic='yes']">
      <!-- OBSOLETE
      <admst:when test="[dynamic='yes' and $DDTFUNC!='twopass']">
      -->
        <!-- dQ_dV -->
        <admst:variable name="lname" value="dynamic"/>
        <admst:text format="$(lname)_"/>
        <admst:choose>
          <admst:when test="$srcnnode[grounded='no']">
            <admst:text
              format="residual2($srcpname,$srcnname,%(e(rhs/tree)));\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="residual1($srcpname,%(e(rhs/tree)));\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <!-- dI_dV -->
        <admst:variable name="lname" value="static"/>
        <admst:text format="$(lname)_"/>
        <admst:choose>
          <admst:when test="$srcnnode[grounded='no']">
            <admst:text
              format="residual2($srcpname,$srcnname,%(e(rhs/tree)));\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="residual1($srcpname,%(e(rhs/tree)));\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="[$emit_defines='yes']">
      <admst:text format="#if defined(_DERIVATE)\n"/>
    </admst:if>
    <admst:for-each select="rhs/probe">
      <admst:variable name="prbpnode" path="branch/pnode"/>
      <admst:variable name="prbnnode" path="branch/nnode"/>
      <admst:variable name="prbpname" path="$prbpnode/name"/>
      <admst:variable name="prbnname" path="$prbnnode/name"/>
      <admst:variable name="pprobe" path="."/>
      <admst:apply-templates select="../tree" match="%(datatypename)"/>
      <admst:if test="[math:is_zero($ep)/value='no']">

        <!--
          Test to make sure that the elements are actually in the
          Jacobian.  If the branches are independent, the cross terms
          will be missing, so referencing is not good.
          ---- currently unused
        <admst:variable name="injac" value="no"/>
        <admst:for-each select="jacobian">
          <admst:variable name="row" value="%(row/name)"/>
          <admst:variable name="col" value="%(column/name)"/>
          <admst:if test="[($col=$prbnname or $col=$prbpname) and
              ($row=$srcpname or $row=$srcnname)]">
            <admst:variable name="injac" value="yes"/>
          </admst:if>
        </admst:for-each>

        <admst:if test="[$injac='yes']">
        -->
          <admst:text format="$(indent)_load_$(lname)_"/>
          <admst:choose>
            <admst:when test="$prbnnode[grounded='no']">
              <admst:if test="$srcnnode[grounded='no']">
                <admst:text
  format="jacobian4($srcpname,$srcnname,$prbpname,$prbnname,$ep);\n"/>
              </admst:if>
              <admst:if test="$srcnnode[grounded='yes']">
                <admst:text
                  format="jacobian2p($srcpname,$prbpname,$prbnname,$ep);\n"/>
              </admst:if>
            </admst:when>
            <admst:otherwise>
              <admst:if test="$srcnnode[grounded='no']">
                <admst:text
                  format="jacobian2s($srcpname,$srcnname,$prbpname,$ep);\n"/>
              </admst:if>
              <admst:if test="$srcnnode[grounded='yes']">
                <admst:text
                  format="jacobian1($srcpname,$prbpname,$ep);\n"/>
              </admst:if>
            </admst:otherwise>
          </admst:choose>
        <!-- </admst:if> -->
      </admst:if>
    </admst:for-each>
  </admst:if>

  <admst:if test="[$emit_defines='yes']">
    <admst:text format="#endif // _DERIVATE\n"/>
  </admst:if>
  <admst:if test="rhs/function">
    <admst:apply-templates select="." match="pop_indent"/>
    <admst:text format="$(indent)}\n"/>
  </admst:if>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="[dynamic='yes']" format="#endif // _DYNAMIC\n"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="conditional">
  <admst:variable name="c_ddxblk" value="no"/>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="if[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  </admst:if>
  <admst:variable name="brbak" value="$nobrackets"/>
  <admst:if test="if/function">
    <admst:variable name="c_ddxblk" value="%(function:ddxblock(if)/value)"/>
    <admst:if test="[$c_ddxblk='yes']">
      <admst:text format="$(indent){\n"/>
      <admst:apply-templates select="." match="push_indent"/>
      <admst:apply-templates select="if/function"
        match="function:precomputation"/>
    </admst:if>
  </admst:if>
  <admst:variable name="nobrackets" value="yes"/>
  <admst:if test="if/tree[datatypename='mapply_binary']">
    <admst:variable name="noparens" value="yes"/>
  </admst:if>
  <admst:text format="$(indent)if (%(e(if/tree))) {\n"/>
  <admst:apply-templates select="." match="push_indent"/>
  <admst:apply-templates select="then" match="%(adms/datatypename)"/>
  <admst:apply-templates select="." match="pop_indent"/>
  <admst:text  format="$(indent)}\n"/>
  <admst:variable name="nobrackets" value="$brbak"/>
  <admst:if test="else">
    <admst:variable name="nobrackets" value="yes"/>
    <admst:text format="$(indent)else {\n"/>
    <admst:apply-templates select="." match="push_indent"/>
    <admst:apply-templates select="else" match="%(adms/datatypename)"/>
    <admst:apply-templates select="." match="pop_indent"/>
    <admst:text format="$(indent)}\n"/>
    <admst:variable name="nobrackets" value="$brbak"/>
  </admst:if>
  <admst:if test="[$c_ddxblk='yes']">
    <admst:apply-templates select="." match="pop_indent"/>
    <admst:text format="$(indent)}\n"/>
  </admst:if>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="if[dynamic='yes']" format="#endif // _DYNAMIC\n"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="nilled">
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="whileloop">
  <admst:variable name="brbak" value="$nobrackets"/>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="while[dynamic='yes']"
      format="#if defined(_DYNAMIC)\n"/>
  </admst:if>
  <admst:variable name="tmpsp" value="$SkipProbe"/>
  <admst:variable name="SkipProbe" select="yes"/>
  <admst:if test="while/tree[datatypename='mapply_binary']">
    <admst:variable name="noparens" value="yes"/>
  </admst:if>
  <admst:text format="$(indent)while (%(e(while/tree))) {\n"/>
  <admst:variable name="SkipProbe" select="$tmpsp"/>
  <admst:variable name="nobrackets" value="yes"/>
  <admst:apply-templates select="." match="push_indent"/>
  <admst:apply-templates select="whileblock" match="%(adms/datatypename)"/>
  <admst:apply-templates select="." match="pop_indent"/>
  <admst:text format="$(indent)}\n"/>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="while[dynamic='yes']" format="#endif // _DYNAMIC\n"/>
  </admst:if>
  <admst:variable name="nobrackets" value="$brbak"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="forloop">
  <admst:variable name="brbak" value="$nobrackets"/>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="condition[dynamic='yes']"
      format="#if defined(_DYNAMIC)\n"/>
  </admst:if>
  <admst:variable name="tmpsp" value="$SkipProbe"/>
  <admst:variable name="SkipProbe" string="yes"/>
  <admst:text format="$(indent)for ("/>
  <admst:text format="%(e(initial/lhs/variable)) = %(e(initial/rhs/tree));"/>
  <admst:text format="%(e(condition/tree));"/>
  <admst:text format="%(e(update/lhs/variable)) = %(e(update/rhs/tree))"/>
  <admst:text format=") {\n"/>
  <admst:variable name="SkipProbe" select="$tmpsp"/>
  <admst:variable name="nobrackets" value="yes"/>
  <admst:apply-templates select="." match="push_indent"/>
  <admst:apply-templates select="forblock" match="%(datatypename)"/>
  <admst:apply-templates select="." match="pop_indent"/>
  <admst:text format="$(indent)}\n"/>
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="condition[dynamic='yes']"
      format="#endif // _DYNAMIC\n"/>
  </admst:if>
  <admst:variable name="nobrackets" value="$brbak"/>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="case">
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="case[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  </admst:if>
<!-- New code: translate to switch statement. -->
  <admst:text format="$(indent)switch (%(e(case/tree))) {\n"/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='no']">
      <admst:for-each select="condition">
        <admst:apply-templates select="." match="%(datatypename)"/>
        <admst:text format="$(indent)case $e:\n"/>
      </admst:for-each>
      <admst:apply-templates select="." match="push_indent"/>
      <admst:apply-templates select="code" match="%(datatypename)"
        required="yes"/>
      <admst:text format="$(indent)break;\n"/>
      <admst:apply-templates select="." match="pop_indent"/>
    </admst:if>
    <admst:if test="[defaultcase='yes']">
      <admst:text format="$(indent)default:\n"/>
      <admst:apply-templates select="." match="push_indent"/>
      <admst:apply-templates select="code" match="%(datatypename)"
        required="yes"/>
      <admst:text format="$(indent)break;\n"/>
      <admst:apply-templates select="." match="pop_indent"/>
    </admst:if>
  </admst:for-each>
  <admst:text format="$(indent)}\n"/>
<!-- Old code: translate to if/else if/else block.
  <admst:variable name="casecondition" path="case/tree"/>
  <admst:variable name="havedefault" string="no"/>
  <admst:variable name="brbak" value="$nobrackets"/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='yes']">
      <admst:variable name="havedefault" string="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:variable name="else" select=""/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='no']">
      <admst:variable name="nobrackets" value="yes"/>
      <admst:text format="$(indent)$(else)if ("/>
      <admst:join select="condition" separator="||">
        <admst:apply-templates select="." match="%(datatypename)"/>
        <admst:variable name="etmp" value="$e"/>
	<admst:text format="(%(e($casecondition)))==($etmp)"/>
      </admst:join>
      <admst:text format=") {\n"/>
      <admst:apply-templates select="." match="push_indent"/>
      <admst:apply-templates select="code" match="%(datatypename)"
        required="yes"/>
      <admst:apply-templates select="." match="pop_indent"/>
      <admst:text  format="$(indent)}\n"/>
      <admst:variable name="nobrackets" value="$brbak"/>
      <admst:variable name="else" value="else "/>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='yes']">
      <admst:variable name="nobrackets" value="yes"/>
      <admst:text format="$(indent)$(else){\n"/>
      <admst:apply-templates select="." match="push_indent"/>
      <admst:apply-templates select="code" match="%(datatypename)"
        required="yes"/>
      <admst:apply-templates select="." match="pop_indent"/>
      <admst:text  format="$(indent)}\n"/>
      <admst:variable name="nobrackets" value="$brbak"/>
    </admst:if>
  </admst:for-each>
-->
  <admst:if test="[$emit_defines='yes']">
    <admst:text select="case[dynamic='yes']" format="#endif // _DYNAMIC\n"/>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<admst:template match="variable:declaration">
  <admst:variable name="myvar" select="%(.)"/>
  <admst:new datatype="list" arguments="list of ddx probes">
    <admst:variable name="ddxprobes" select="%(.)"/>
    <admst:for-each select="$myvar/probe">
      <admst:variable name="pprobe" select="%(.)"/>
      <admst:push into="$ddxprobes/item"
        select="$myvar/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
        .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
    </admst:for-each>
  </admst:new>
  <admst:if test="block/adms[datatypename='module']">
    <admst:if test="[$emit_defines='yes']">
      <admst:if test="[static='no' and dynamic='yes']">
        <admst:if test="[($SkipDCL='no' and scope='local') or
            ($SkipProbe='no' and count([insource='yes']/probe)!=0)]">
          <admst:text format="#if defined(_DYNAMIC)\n"/>
        </admst:if>
      </admst:if>
    </admst:if>
    
    <!-- array support 111017 -->
    <admst:variable name="isarray" value="no"/>
    <admst:if test="[minsize!=maxsize]">
      <!-- an array -->
      <admst:variable name="isarray" value="yes"/>
      <admst:apply-templates select="." match="math:asizeval"/>
      <admst:variable name="subscr" value="$leftval"/>
    </admst:if>

    <admst:if test="[$SkipDCL='no']">
      <!--
        The module variables are assumed initialized to zero in
        Verilog, so we will initialize the variables and derivatives
        to zero here.
      -->
      <admst:if test="[scope='local']">
        <admst:choose>
          <admst:when test="[type='real']">
            <admst:if test="[$isarray='yes']">
              <admst:text
  format="$(indent)%(vtype(.)) %(name)[$subscr] = {0.0};\n"/>
            </admst:if>
            <admst:if test="[$isarray='no']">
              <admst:text
  format="$(indent)%(vtype(.)) %(name) = 0.0;\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:if test="[$isarray='yes']">
  format="$(indent)%(vtype(.)) %(name)[$subscr] = {0};\n"/>
            </admst:if>
            <admst:if test="[$isarray='no']">
              <admst:text
  format="$(indent)%(vtype(.)) %(name) = 0;\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
    <admst:if test="[$SkipProbe='no']">
      <admst:if test="[insource='yes']/probe">
        <admst:for-each select="probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:if test="../ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
              .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidederivate" select="yes"/>
          </admst:if>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
          <admst:choose>
            <admst:when test="[$ddxinsidederivate='yes']">
              <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
            </admst:when>
            <admst:otherwise>
              <admst:text format="#if defined(_DERIVATE)\n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:if>

        <admst:for-each select="$myvar/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:text format="$(indent)double "/>
          <admst:if test="[$isarray='yes']">
            <admst:text
  format="%(dxname($myvar)/[name='dxname']/value)[$subscr] = {0.0};\n"/>
          </admst:if>
          <admst:if test="[$isarray='no']">
            <admst:text
  format="%(dxname($myvar)/[name='dxname']/value) = 0.0;\n"/>
          </admst:if>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidederivate='yes']"
            format="#if defined(_DERIVATE2)\n"/>
        </admst:if>
        <admst:for-each select="$ddxprobes/item">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:for-each select="$myvar/probe">
            <admst:variable name="qprobe" select="%(.)"/>
            <admst:text format="$(indent)double "/>
            <admst:if test="[$isarray='yes']">
              <admst:text
  format="%(ddxname($myvar)/[name='ddxname']/value)[$subscr] = {0.0};\n"/>
            </admst:if>
            <admst:if test="[$isarray='no']">
              <admst:text
  format="%(ddxname($myvar)/[name='ddxname']/value) = 0.0;\n"/>
            </admst:if>
          </admst:for-each>
        </admst:for-each>

        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidederivate='yes']"
            format="#endif // _DERIVATE2\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:if test="[$emit_defines='yes']">
              <admst:text format="#endif // _DERIVATEFORDDX\n"/>
            </admst:if>
            <admst:variable name="ddxinsidederivate" select="no"/>
          </admst:when>
          <admst:otherwise>
            <admst:if test="[$emit_defines='yes']">
              <admst:text format="#endif // _DERIVATE\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
    <admst:if test="[$emit_defines='yes']">
      <admst:if test="[static='no' and dynamic='yes']">
        <admst:if test="[($SkipDCL='no' and scope='local') or
            ($SkipProbe='no' and count([insource='yes']/probe)!=0)]">
          <admst:text format="#endif // _DYNAMIC\n"/>
        </admst:if>
      </admst:if>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Inject printf statements for the variable and its derivates, for
  debugging.
-->
<admst:template match="variable:printf">
  <admst:variable name="myvar" select="%(.)"/>
  <admst:new datatype="list" arguments="list of ddx probes">
    <admst:variable name="ddxprobes" select="%(.)"/>
    <admst:for-each select="$myvar/probe">
      <admst:variable name="pprobe" select="%(.)"/>
      <admst:push into="$ddxprobes/item"
        select="$myvar/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
        .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
    </admst:for-each>
  </admst:new>
  <admst:if test="block/adms[datatypename='module']">
    <admst:if test="[$emit_defines='yes']">
      <admst:if test="[static='no' and dynamic='yes']">
        <admst:if test="[($SkipDCL='no' and scope='local') or
            ($SkipProbe='no' and count([insource='yes']/probe)!=0)]">
          <admst:text format="#if defined(_DYNAMIC)\n"/>
        </admst:if>
      </admst:if>
    </admst:if>
    <admst:if test="[$SkipDCL='no']">
      <admst:if test="[scope='local']">
        <admst:choose>
          <admst:when test="[type='real']">
            <admst:text format="$(indent)printf(&quot;%(name) = %%g\\n&quot;, %(name));\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="$(indent)printf(&quot;%(name) = %%d\\n&quot;, %(name));\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
    <admst:if test="[$SkipProbe='no']">
      <admst:if test="[insource='yes']/probe">
        <admst:for-each select="probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:if test="../ddxprobe/branch/pnode[.=$pprobe/branch/pnode or
              .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidederivate" select="yes"/>
          </admst:if>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
          <admst:choose>
            <admst:when test="[$ddxinsidederivate='yes']">
              <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
            </admst:when>
            <admst:otherwise>
              <admst:text format="#if defined(_DERIVATE)\n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:if>
        <admst:for-each select="$myvar/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:variable name="nm"
            select="%(dxname($myvar)/[name='dxname']/value)"/>
          <admst:text
            format="$(indent)printf(&quot;$nm = %%g\\n&quot;, $nm);\n"/>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidederivate='yes']"
            format="#if defined(_DERIVATE2)\n"/>
        </admst:if>
        <admst:for-each select="$ddxprobes/item">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:for-each select="$myvar/probe">
            <admst:variable name="qprobe" select="%(.)"/>
            <admst:variable name="nm"
              select="%(ddxname($myvar)/[name='ddxname']/value)"/>
            <admst:text
              format="$(indent)printf(&quot;$nm = %%g\\n&quot;, $nm);\n"/>
          </admst:for-each>
        </admst:for-each>
        <admst:if test="[$emit_defines='yes']">
          <admst:text test="[$ddxinsidederivate='yes']"
            format="#endif // _DERIVATE2\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:if test="[$emit_defines='yes']">
              <admst:text format="#endif // _DERIVATEFORDDX\n"/>
            </admst:if>
            <admst:variable name="ddxinsidederivate" select="no"/>
          </admst:when>
          <admst:otherwise>
            <admst:if test="[$emit_defines='yes']">
              <admst:text format="#endif // _DERIVATE\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
    <admst:if test="[$emit_defines='yes']">
      <admst:if test="[static='no' and dynamic='yes']">
        <admst:if test="[($SkipDCL='no' and scope='local') or
            ($SkipProbe='no' and count([insource='yes']/probe)!=0)]">
          <admst:text format="#endif // _DYNAMIC\n"/>
        </admst:if>
      </admst:if>
    </admst:if>
  </admst:if>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  This template scans the module for calls to the $port_connected
  function.  The argument to the call will have its 'optional'
  attribute set to 'yes'.  Before making this call, the attribute
  should be created in all nodes (if it doesn't exist) and initialized
  to 'no'.  Note that the user can set this from the Verilog source
  with (* optional="yes" *), this may or may not be good.
-->
<admst:template match="find:optports">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="find:optports"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="find:optports"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="find:optports"/>
      <admst:apply-templates select="then" match="find:optports"/>
      <admst:apply-templates select="else" match="find:optports"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="find:optports"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:apply-templates select="." match="find:optports"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="find:optports"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="find:optports"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="forblock" match="find:optports"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:apply-templates select="rhs" match="find:optports"/>
    </admst:when>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>

    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="find:optports"/>
    </admst:when>
    <admst:when test="[datatypename='probe']"/>
    <admst:when test="[datatypename='array']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="find:optports"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="find:optports"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="find:optports"/>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:if test="[name='\$port_connected']">
        <admst:value-to 
          select="arguments[1]/attribute[name='optional']/value" value="yes"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:otherwise>
      <admst:warning format="find:optports: unhandled type %(datatypename).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Search through all of the probes, and list the "flow" probes found
  which have a form like I(x,x), where x is an external node.  These
  will require some special setup.  Note that adms-2.3.0-wr030714 and
  later will map input I(<x>) -> I(x,x).
-->
<admst:template match="find:curprobes">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="find:curprobes"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="find:curprobes"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="find:curprobes"/>
      <admst:apply-templates select="then" match="find:curprobes"/>
      <admst:apply-templates select="else" match="find:curprobes"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="find:curprobes"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:apply-templates select="." match="find:curprobes"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="find:curprobes"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="find:curprobes"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="forblock" match="find:curprobes"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:apply-templates select="rhs" match="find:curprobes"/>
    </admst:when>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="find:curprobes"/>
    </admst:when>

    <admst:when test="[datatypename='probe']">
      <admst:if test="[nature=discipline/flow]">
        <admst:variable name="pname" string="%(branch/pnode/name)"/>
        <admst:variable name="nname" string="%(branch/nnode/name)"/>
        <!--
          I(<x>) is equivalent to I(x,x), pnode==nnode.  I(x) has
          nnode==Gnd, which we treat in the same way.
        -->
        <admst:if test="[$pname=$nname or branch/nnode/grounded='yes']">
          <admst:if test="branch/pnode[location='external']">
            <admst:push into="$curprobes" select="." onduplicate="ignore"/>
          </admst:if>
        </admst:if>
      </admst:if>
    </admst:when>

    <admst:when test="[datatypename='array']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="find:curprobes"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="find:curprobes"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="find:curprobes"/>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:for-each select="arguments">
        <admst:apply-templates select="." match="find:curprobes"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='node']"/>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:otherwise>
      <admst:warning format="find:curprobes: unhandled type %(datatypename).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  This template fills in lists of parameters and variables, separated
  for model/instance structure elements and locals.  Not all translation
  units require this initialization.
-->
<admst:template match="init:variables">
  <!--
    The following variable attributes are provided from adms.implicit:
      setinmodel         variable assigned in model initialization block
      setininstance      variable assigned in instance initialization block
      setininitial_step  variable assigned in "initial_step" block
      setinnoise         variable assigned in "noise" block
      setinfinal         variable assigned in "final_step" block
      setinevaluate      none of above
  -->

  <!-- These will be in the model struct. -->
  <admst:variable name="model_vars"
    select="%(variable[setinmodel='yes' and scope='local'] |
    analog/code/variable[setinmodel='yes' and scope='local'])"/>

  <!-- These will be in the instance struct. -->
  <admst:variable name="instance_vars"
    select="%(variable[setininstance='yes' and scope='local'] |
    analog/code/variable[setininstance='yes' and scope='local'])"/>

  <!--
    If a variable is found in both lists, this is an error.  If we
    assume a model parameter, it will be set in instance code, which
    is not allowable.  If we assume an instance parameter, it will be
    used in code where there is no instance in scope.
  -->
  <admst:for-each select="$model_vars">
    <admst:variable name="vv" value="%(name)"/>
    <admst:if test="$instance_vars[name='$vv']">
      <admst:fatal
  format="init:variables: variable %(name) set in both model and instance initialization blocks.\n"/>
    </admst:if>
  </admst:for-each>

  <!-- 
    Not sure what "insource" is, but some of the local variables in
    bsimsoi.va need it for ddx and don't have it set to 'yes' initially.
    the value is reset in the folowing blocks.
  -->

  <!-- These are locals, declared in the model loop. -->
  <admst:for-each select="variable">
    <!-- module variables -->
    <admst:if test="[parametertype!='instance' and
        scope!='global_instance' and scope!='global_model']">
      <admst:variable name="vv" value="%(name)"/>
      <admst:choose>
        <admst:when test="$model_vars[name=$vv]"/>
        <admst:when test="$instance_vars[name=$vv]"/>
        <admst:otherwise>
          <admst:push into="$model_local_vars" select="."
            onduplicate="ignore"/>
          <admst:value-to select="insource" string="yes"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="analog/code/variable">
    <!-- block variables -->
    <admst:if test="[parametertype!='instance' and
        scope!='global_instance' and scope!='global_model']">
      <admst:variable name="vv" value="%(name)"/>
      <admst:choose>
        <admst:when test="$model_vars[name=$vv]"/>
        <admst:when test="$instance_vars[name=$vv]"/>
        <admst:otherwise>
          <admst:push into="$model_local_vars" select="."
            onduplicate="ignore"/>
          <admst:value-to select="insource" string="yes"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
  </admst:for-each>

  <!-- These are locals, declared in the instance loop, not output vars -->
  <admst:for-each select="variable">
    <!-- module variables -->
    <admst:if test="[parametertype='instance' and
        scope!='global_model' and scope!='global_instance' and
        nilled(attribute)]">
      <admst:variable name="vv" value="%(name)"/>
      <admst:choose>
        <admst:when test="$instance_vars[name='$vv']"/>
        <admst:when test="$model_vars[name='$vv']"/>
        <admst:otherwise>
          <admst:push into="$instance_local_vars" select="."
            onduplicate="ignore"/>
          <admst:value-to select="insource" string="yes"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
    <admst:if test="[parametertype='instance' and
        scope!='global_model' and scope!='global_instance' and
        not(nilled(attribute))]">
      <!--
        These are "output" variables, they are used in expressions so
        need derivates, so insource should be yes.
      -->
      <admst:value-to select="insource" string="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="analog/code/variable">
    <!-- block variables -->
    <admst:if test="[parametertype='instance' and
        scope!='global_model' and scope!='global_instance' and
        nilled(attribute)]">
      <admst:variable name="vv" value="%(name)"/>
      <admst:choose>
        <admst:when test="$instance_vars[name='$vv']"/>
        <admst:when test="$model_vars[name='$vv']"/>
        <admst:otherwise>
          <admst:push into="$instance_local_vars" select="."
            onduplicate="ignore"/>
          <admst:value-to select="insource" string="yes"/>
        </admst:otherwise>
      </admst:choose>
    </admst:if>
    <admst:if test="[parametertype='instance' and
        scope!='global_model' and scope!='global_instance' and
        not(nilled(attribute))]">
      <admst:value-to select="insource" string="yes"/>
    </admst:if>
  </admst:for-each>

<!-- DEBUG
  <admst:for-each select="$model_vars">
    <admst:text format="model: %(name) %(input) %(scope) %(parametertype) %(insource)
 %(setinmodel) %(setininstance) %(setininitial_step) %(setinnoise) %(setinfinal) %(setinevaluate)\n"/>
  </admst:for-each>
  <admst:for-each select="$model_local_vars">
    <admst:text format="model local: %(name) %(input) %(scope) %(OPdependent) %(insource)
 %(setinmodel) %(setininstance) %(setininitial_step) %(setinnoise) %(setinfinal) %(setinevaluate)\n"/>
  </admst:for-each>
  <admst:for-each select="$instance_vars">
    <admst:text format="instance: %(name) %(input) %(scope) %(parametertype) %(insource)
 %(setinmodel) %(setininstance) %(setininitial_step) %(setinnoise) %(setinfinal) %(setinevaluate)\n"/>
  </admst:for-each>
  <admst:for-each select="$instance_local_vars">
    <admst:text format="instance local: %(name) %(input) %(scope) %(OPdependent) %(insource)
 %(setinmodel) %(setininstance) %(setininitial_step) %(setinnoise) %(setinfinal) %(setinevaluate)\n"/>
  </admst:for-each>
-->

</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  Callback for the findfunc template used when checking that
  contribution operators are not used outside of contributions.
-->
<admst:template match="ff_atest">
  <admst:choose>
    <admst:when test="[name='ddt']">
      <admst:warning
        format="A ddt operator was found not in a contribution line.\n"/>
      <admst:warning format="This is not supported at present.\n"/>
      <admst:fatal format="Buh bye!\n"/>
    </admst:when>
    <admst:when test="[name='white_noise']">
      <admst:warning
        format="A white_noise operator was found not in a contribution line.\n"/>
      <admst:warning format="This is not supported.\n"/>
      <admst:fatal format="Buh bye!\n"/>
    </admst:when>
    <admst:when test="[name='flicker_noise']">
      <admst:warning
        format="A flicker_noise operator was found not in a contribution line.\n"/>
      <admst:warning format="This is not supported.\n"/>
      <admst:fatal format="Buh bye!\n"/>
    </admst:when>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------------- -->
<!--
  This template should be called first when translating.
-->
<admst:template match="init:translation">
  <!--
    We can't handle more than one module in the source.
  -->
  <admst:if test="[count(/module)!=1]">
    <admst:fatal
      format="Sorry, I can process only one module per source file.\n"/>
  </admst:if>

  <!--
    Set the name token used for the module.  This is specified by the
    user, in the device.xml file.
  -->
  <admst:new datatype="attribute" arguments="wrsmodname">
    <admst:push into="../attribute" select="." onduplicate="abort"/>
    <admst:value-to select="value" value="$package_module"/>
  </admst:new>
  <admst:variable name="module" value="$package_module"/>
  <admst:variable name="moduc" select="%(upper-case($module))"/>
  <admst:variable name="modlc" select="%(lower-case($module))"/>

  <!--
    Here we insert the model names into the model parameter list. 
    This is dependent upon the device key, per SPICE custom.

    The model key is given in the device.xml file, and MUST be
    lower-case.

    WRspice requires that the model name(s) must be model parameters. 
    This is a no-op except for devices with p/n flavors, in which case
    this will set the flavor.  E.g., ".model mybjt npn ..." specifies
    an npn transistor.

    There's a problem here:  the Verilog model probably has its own
    way to set the p/n flavor.  We need to figure out how it works,
    and hook to it.  If the Verilog code has a parameter with a name
    matching one of the model names, one or both of the variables
    has_n_flavor of has_p_flavor will be set to 'yes'.  If either is
    set, we're (sort of) good.  We assume that these are flags [0:1]
    indicating device type.  If not, we have to apply some cleverness
    later.
  -->
  <admst:choose>
    <admst:when test="[
        $package_devkey='a' or
        $package_devkey='b' or
        $package_devkey='c' or
        $package_devkey='d' or
        $package_devkey='e' or
        $package_devkey='f' or
        $package_devkey='g' or
        $package_devkey='h' or
        $package_devkey='i' or
        $package_devkey='l' or
        $package_devkey='n' or
        $package_devkey='o' or
        $package_devkey='p' or
        $package_devkey='r' or
        $package_devkey='s' or
        $package_devkey='t' or
        $package_devkey='u' or
        $package_devkey='v' or
        $package_devkey='w' or
        $package_devkey='y']">

      <!-- Source devices are allowed now -->
      <!-- a: Spice3 arbitrary source -->
      <!-- e:  voltage-controlled voltage source -->
      <!-- f:  current-controlled current source -->
      <!-- g:  voltage-conttrolled current source -->
      <!-- h:  current-controlled voltage source -->
      <!-- i: current source -->
      <!-- v: voltage source -->

      <!-- b: josephson junction -->
      <!-- c: capacitor -->
      <!-- d: diode -->
      <!-- l: inductor -->
      <!-- n: unassigned -->
      <!-- o: transmission line -->
      <!-- p: unassigned -->
      <!-- r: resistor -->
      <!-- s: voltage-controlled switch -->
      <!-- t: transmission line -->
      <!-- u: lumped-element (urc) transmission line -->
      <!-- w: current-controlled switch -->
      <!-- y: unassigned -->

      <admst:if test="[nilled(variable[name='$package_devkey'])]">
        <admst:value-of select="analog"/>
        <admst:value-of select="."/>
        <admst:new datatype="variable" arguments="%p,$package_devkey,%p">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" value="scalar"/>
          <admst:value-to select="type" value="integer"/>
          <admst:value-to select="input" value="yes"/>
          <admst:value-to select="output" value="yes"/>
          <admst:value-to select="parametertype" value="model"/>
          <admst:value-to select="scope" value="global_model"/>
          <admst:new datatype="number" arguments="0">
            <admst:value-to select="scalingunit" value="1"/>
            <admst:value-of select="."/>
            <admst:value-of select="../module"/>
            <admst:new datatype="expression" arguments="%p,%p">
              <admst:value-of select="."/>
              <admst:value-to select="../../default" value="%p"/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
    </admst:when>
    <admst:when test="[$package_devkey='j']">
      <!-- j: junction fet -->
      <admst:variable name="n_flavor" value="njf"/>
      <admst:variable name="p_flavor" value="pjf"/>
    </admst:when>
    <admst:when test="[$package_devkey='m']">
      <!-- m: mos transistor -->
      <admst:variable name="n_flavor" value="nmos"/>
      <admst:variable name="p_flavor" value="pmos"/>
    </admst:when>
    <admst:when test="[$package_devkey='q']">
      <!-- q: bipolar transistor -->
      <admst:variable name="n_flavor" value="npn"/>
      <admst:variable name="p_flavor" value="pnp"/>
    </admst:when>
    <admst:when test="[$package_devkey='z']">
      <!-- z: mesfet -->
      <admst:variable name="n_flavor" value="nmf"/>
      <admst:variable name="p_flavor" value="pmf"/>
    </admst:when>

    <admst:otherwise>
       <!-- key not recognized or device type can't be added.  We don't
            allow k, x.
       -->
      <admst:value-of select="name"/>
      <admst:fatal
  format="%s: device key '$package_devkey' not allowed by the WRspice adms interface.\n"/>
    </admst:otherwise>
  </admst:choose>

  <!--
    Create dummy parameters for the SPICE n/p model names.  These must
    be accepted as model parameters.
  -->
  <admst:if test="[$n_flavor!='']">
    <admst:choose>
      <admst:when test="[nilled(variable[name='$n_flavor'])]">
        <admst:value-of select="analog"/>
        <admst:value-of select="."/>
        <admst:new datatype="variable" arguments="%p,$n_flavor,%p">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" value="scalar"/>
          <admst:value-to select="type" value="integer"/>
          <admst:value-to select="input" value="yes"/>
          <admst:value-to select="output" value="yes"/>
          <admst:value-to select="parametertype" value="model"/>
          <admst:value-to select="scope" value="global_model"/>
          <admst:new datatype="number" arguments="0">
            <admst:value-to select="scalingunit" value="1"/>
            <admst:value-of select="."/>
            <admst:value-of select="../module"/>
            <admst:new datatype="expression" arguments="%p,%p">
              <admst:value-of select="."/>
              <admst:value-to select="../../default" value="%p"/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="has_n_flavor" value="yes"/>
      </admst:otherwise>
    </admst:choose>
    <admst:choose>
      <admst:when test="[nilled(variable[name='$p_flavor'])]">
        <admst:value-of select="analog"/>
        <admst:value-of select="."/>
        <admst:new datatype="variable" arguments="%p,$p_flavor,%p">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" value="scalar"/>
          <admst:value-to select="type" value="integer"/>
          <admst:value-to select="input" value="yes"/>
          <admst:value-to select="output" value="yes"/>
          <admst:value-to select="parametertype" value="model"/>
          <admst:value-to select="scope" value="global_model"/>
          <admst:new datatype="number" arguments="0">
            <admst:value-to select="scalingunit" value="1"/>
            <admst:value-of select="."/>
            <admst:value-of select="../module"/>
            <admst:new datatype="expression" arguments="%p,%p">
              <admst:value-of select="."/>
              <admst:value-to select="../../default" value="%p"/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="has_p_flavor" value="yes"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>

  <!-- Not sure wtf this is. -->
  <admst:if test="analog/code/variable[derivate='yes' and insource='yes']">
    <admst:variable name="requiredderivateforddx" select="yes"/>
  </admst:if>
  <admst:if test="variable[derivate='yes' and insource='yes']">
    <admst:variable name="requiredderivateforddx" select="yes"/>
  </admst:if>

  <!--
    There is no way to separate "model" and "instance" parameters in
    raw Verilog.  The Verilog source can have the adms type=instance
    attribute added to instance parameters to get around this. 
    Otherwise, there will be no instance parameters at this point. 
    This is not compatible with WRspice (though the code will compile)
    since the model struct will hold per-instance values, violating
    the model/instance partitioning.

    To get around this, when no instance parameters are detected, we
    make all parameters instance parameters, and have separate shadows
    of all parameters in the model struct.  The parameters in the
    model struct will be set from the .model line, and these in turn
    initialize the corresponding parameters in the instance struct. 
    In this case, the model struct contains only the shadow parameters
    and the instance list.  We have to convert any "initial_model"
    blocks to "initial_instance", and move local variables to instance
    scope.

    Note that in this case all parameters can be set in WRspice from
    either a .model line or the instance line.  This configuration
    works fine, but consumes a lot of memory for large parameter sets. 
    The way around this is for model developers to make use of the
    adms extensions to identify instance parameters and model/instance
    initial blocks.  This is the only way that correct model/instance
    partitioning can be obtained.
  -->
  <admst:choose>
    <admst:when test="[count(block[name='initial_instance' or
        name='initializeInstance'])!=0 and count(block[name='initial_model' or
        name='initializeModel'])!=0]">
      <admst:message format="found adms partitioning block names\n"/>
      <!--
        Has initial_instance and initial_model blocks, use the
        resulting partitioning even if there are no instance
        parameters.
      -->
    </admst:when>
    <admst:when test="variable[parametertype='instance' and input='yes']">
      <!--
        At least one parameter was specified as an instance parameter,
        so we will respect the given partitioning.
      -->
      <admst:message format="using specified partitioning\n"/>
    </admst:when>
    <admst:otherwise>
      <!-- Flag this case. -->
      <admst:variable name="unified" value="yes"/>
      <admst:message format="using unified partitioning\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="[$unified!='yes']">
    <!--
      We have to be careful with "output" parameters.  These are
      global non-parameter declarations with attributes, e.g.,
        real blah (* info="blah" *);
      We will take these as instance parameters, unless a type='model'
      attribute is given explicitly.
    -->
    <admst:for-each select="variable[parametertype='model' and input!='yes'
        and not(nilled(attribute))]">
      <admst:choose>
        <admst:when test="[attribute[name='type']/value='model']"/>
          <!-- Explicit model type, leave as-is. -->
        <admst:otherwise>
          <!-- Make this an instance parameter. -->
          <admst:value-to select="parametertype" string="instance"/>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
  </admst:if>

  <admst:if test="[$unified='yes']">
    <!--
      Move all parameters and variables to instance scope, unless
      they have an explicit type="model" attribute.
    -->
    <admst:for-each select="variable[parametertype='model']">
      <admst:choose>
        <admst:when test="[attribute[name='type']/value='model']"/>
        <admst:otherwise>
          <admst:value-to select="parametertype" string="instance"/>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
    <admst:for-each select="variable[scope='global_model']">
      <admst:choose>
        <admst:when test="[attribute[name='type']/value='model']"/>
        <admst:otherwise>
          <admst:value-to select="scope" string="global_instance"/>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
    <admst:for-each select="variable[setinmodel='yes']">
      <admst:choose>
        <admst:when test="[attribute[name='type']/value='model']"/>
        <admst:otherwise>
          <admst:value-to select="setinmodel" string="no"/>
          <admst:value-to select="setininstance" string="yes"/>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
    <!--
      Now rename any model initialization blocks found to
      "initial_instance".  There really shouldn't be any of these
      since it appears that the file does not use adms extensions. 
      However, a block may exist by coincidence, and in at least
      one case (hicumL2V2p30_open.va), the "initial_model" adms
      extension is used to name an "initial_model" block, but no
      instance parameters are defined!
    -->
    <admst:for-each select="analog/code/item">
      <admst:if test="adms[datatypename='block']/..[name='initial_model' or
          name='initializeModel']">
        <admst:value-to select="name" string="initial_instance"/>
      </admst:if>
    </admst:for-each>
  </admst:if>

  <!--
    Possibly add an 'm' (multipier) instance parameter.  This will
    multiply the MNA stamp loaded, so acts as a device multiplier.
  -->
  <admst:if test="[$package_add_m='yes' and
      count(/module/variable[name='m' and parametertype='instance'])=0]">
    <admst:value-of select="analog"/>
    <admst:value-of select="."/>
    <admst:new datatype="variable" arguments="%p,m,%p">
      <admst:push into="module/variable" select="." onduplicate="ignore"/>
      <admst:value-to select="sizetype" value="scalar"/>
      <admst:value-to select="type" value="real"/>
      <admst:value-to select="input" value="yes"/>
      <admst:value-to select="output" value="yes"/>
      <admst:value-to select="parametertype" value="instance"/>
      <admst:value-to select="scope" value="global_instance"/>
      <admst:new datatype="attribute" arguments="type">
        <admst:push into="../attribute" select="."/>
        <admst:value-to select="value" value="instance"/>
      </admst:new>
      <admst:new datatype="number" arguments="1.0">
        <admst:value-to select="scalingunit" value="1"/>
        <admst:value-of select="."/>
        <admst:value-of select="../module"/>
        <admst:new datatype="expression" arguments="%p,%p">
          <admst:value-of select="."/>
          <admst:value-to select="../../default" value="%p"/>
        </admst:new>
      </admst:new>
    </admst:new>
    <admst:variable name="added_m" value="yes"/>
  </admst:if>

  <!--
    Find the module's optional ports, if any.  These will be given an
    'optional' attribute of 'yes'.
  -->
  <admst:for-each select="node">
    <admst:if test="[nilled(attribute[name='optional'])]">
      <admst:new datatype="attribute" arguments="optional">
        <admst:push into="../attribute" select="."/>
        <admst:value-to select="value" value="no"/>
      </admst:new>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="analog/code" match="find:optports"/>

  <!-- Check if optional ports are to right of mandatory ports. -->
  <admst:variable name="gotone" value="no"/>
  <admst:variable name="opt" value=""/>
  <admst:for-each select="node[location='external']">
    <admst:variable name="nn" value="%(name)"/>
    <admst:choose>
      <admst:when test="[attribute[name='optional']/value='yes']">
        <admst:variable name="gotone" value="yes"/>
        <admst:variable name="opt" value="$nn"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[$gotone='yes']">
          <admst:warning
  format="I have identified a mandatory port $nn that is listed to the right\n"/>
          <admst:warning
  format="of optional port $opt in the module declaration.  All optional ports\n"/>
          <admst:warning
  format="must be listed to the right of mandatory ports.\n"/>
          <admst:fatal format="Buh bye!\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>

  <!--
    Check that ddt and the noise operators appear only in contributions.
    The parse will terminate if this is not the case.
  -->
  <admst:variable name="findfunc_dofunc" value="ff_atest"/>
  <admst:variable name="findfunc_asonly" value="yes"/>
  <admst:apply-templates select="analog/code" match="findfunc"/>
  <admst:variable name="findfunc_asonly" value="no"/>
  <admst:variable name="findfunc_dofunc" value="dofunc"/>

  <!--
    Initialize the contributions.  This sets the "collapsed" option in
    each contribution for use later, and fills the $branches variable
    with the lhs terms that will require a branch node.  These are the
    V() <+ ...  lhs terms that are not collapsed.  This will also fill
    in the noise contribution lists.
  -->
  <admst:new datatype="list" arguments="fnoise">
    <admst:variable name="fnoise" select="%(.)"/>
  </admst:new>
  <admst:new datatype="list" arguments="tnoise">
    <admst:variable name="tnoise" select="%(.)"/>
  </admst:new>
  <admst:new datatype="list" arguments="wnoise">
    <admst:variable name="wnoise" select="%(.)"/>
  </admst:new>
  <admst:for-each select="contribution">
    <admst:variable name="collapsed" value="%(check_collapsed(.)/value)"/>
    <admst:if test="[nilled(attribute[name='collapsed'])]">
      <admst:new datatype="attribute" arguments="collapsed">
        <admst:push into="../attribute" select="."/>
        <admst:value-to select="value" value="$collapsed"/>
      </admst:new>
    </admst:if>
    <admst:if test="[lhs/nature=lhs/discipline/potential and $collapsed='no']">
      <!--
        These require a branch node added to the circuit matrix.
      -->
      <admst:push into="$branches" select="lhs" onduplicate="ignore"/>
    </admst:if>
    <admst:if test="[lhs/nature=lhs/discipline/potential and $collapsed!='no']">
      <!--
        These require a flag to indicate whether really collapsed.
      -->
      <admst:push into="$collapsable" select="lhs" onduplicate="ignore"/>
    </admst:if>

    <!-- Check noise contributions. -->
    <admst:variable name="contribution" select="%(.)"/>
    <admst:variable name="dependency" select="%(math/dependency)"/>
    <admst:choose>
      <admst:when
  test="rhs/tree/adms[datatypename='function']/..[name='flicker_noise']">
        <admst:push into="$fnoise/item" select="$contribution"
          onduplicate="ignore"/>
      </admst:when>
      <admst:when
  test="[$dependency='constant']/rhs/tree/adms[datatypename='function']/..[name='white_noise']">
        <admst:push into="$tnoise/item" select="$contribution"
          onduplicate="ignore"/>
      </admst:when>
      <admst:when
  test="[$dependency!='constant']/rhs/tree/adms[datatypename='function']/..[name='white_noise']">
        <admst:push into="$wnoise/item" select="$contribution"
          onduplicate="ignore"/>
      </admst:when>
    </admst:choose>
  </admst:for-each>

  <!--
    Check the purity of each contribution.  With $chk_purity set to
    'yes', the appropriate contribution rhs should collapse to zero
    since ddt(), white_noise(), and flicker_noise() return 0.0.
    We know that these operators appear only in contributions.
  -->
  <admst:variable name="SkipProbe" value="yes"/>
  <admst:for-each select="contribution">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:if test="[whitenoise='yes']">
          <admst:warning format="unexpected whitenoise term in %(rhs)\n"/>
        </admst:if>
        <admst:if test="[flickernoise='yes']">
          <admst:warning format="unexpected flickernoise term in %(rhs)\n"/>
        </admst:if>
        <admst:variable name="chk_purity" value="yes"/>
        <admst:apply-templates select="rhs/tree" match="ddx"/>
        <admst:if test="[math:is_zero($e)/value!='yes']">
          <admst:warning format="impure dynamic term in %(rhs)\n"/>
        </admst:if>
        <admst:variable name="chk_purity" value="no"/>
      </admst:when>
      <admst:when test="[whitenoise='yes']">
        <admst:if test="[flickernoise='yes']">
          <admst:warning format="unexpected flickernoise term in %(rhs)\n"/>
        </admst:if>
        <admst:variable name="chk_purity" value="yes"/>
        <admst:apply-templates select="rhs/tree" match="ddx"/>
        <admst:if test="[math:is_zero($e)/value!='yes']">
          <admst:warning format="impure whitenoise term in %(rhs)\n"/>
        </admst:if>
        <admst:variable name="chk_purity" value="no"/>
      </admst:when>
      <admst:when test="[flickernoise='yes']">
        <admst:variable name="chk_purity" value="yes"/>
        <admst:apply-templates select="rhs/tree" match="ddx"/>
        <admst:if test="[math:is_zero($e)/value!='yes']">
          <admst:warning format="impure flickernoise term in %(rhs)\n"/>
        </admst:if>
        <admst:variable name="chk_purity" value="no"/>
      </admst:when>
    </admst:choose>
  </admst:for-each>
  <admst:variable name="SkipProbe" value="no"/>

  <!--
    Fill in the list of noise source names, from strings found in the
    noise function argument list.  If no string argument is present,
    or if it is empty, create a dummy argument or update the string. 
    It is necessary that every noise source have a name.

    This fills in the $noinames variable.
  -->
  <admst:for-each select="$wnoise/item">
    <admst:if test="[count(rhs/tree/arguments)=1]">
      <admst:new datatype="string" inputs="'white'">
        <admst:push into="../rhs/tree/arguments" select="."/>
        <admst:reverse select="../rhs/tree/arguments"/>
      </admst:new>
    </admst:if>
    <admst:if test="[rhs/tree/arguments[2]/value='']">
      <admst:value-to select="rhs/tree/arguments[2]/value" string="white"/>
    </admst:if>
    <admst:push into="$noinames" select="rhs/tree/arguments[2]"
      onduplicate="ignore"/>
  </admst:for-each>
  <admst:for-each select="$tnoise/item">
    <admst:if test="[count(rhs/tree/arguments)=1]">
      <admst:new datatype="string" inputs="'white'">
        <admst:push into="../rhs/tree/arguments" select="."/>
        <admst:reverse select="../rhs/tree/arguments"/>
      </admst:new>
    </admst:if>
    <admst:if test="[rhs/tree/arguments[2]/value='']">
      <admst:value-to select="rhs/tree/arguments[2]/value" string="white"/>
    </admst:if>
    <admst:push into="$noinames" select="rhs/tree/arguments[2]"
      onduplicate="ignore"/>
  </admst:for-each>
  <admst:for-each select="$fnoise/item">
    <admst:if test="[count(rhs/tree/arguments)=2]">
      <admst:new datatype="string" inputs="'flicker'">
        <admst:reverse select="../rhs/tree/arguments"/>
        <admst:push into="../rhs/tree/arguments" select="."/>
        <admst:reverse select="../rhs/tree/arguments"/>
      </admst:new>
    </admst:if>
    <admst:if test="[rhs/tree/arguments[3]/value='']">
      <admst:value-to select="rhs/tree/arguments[3]/value" string="flicker"/>
    </admst:if>
    <admst:push into="$noinames" select="rhs/tree/arguments[3]"
      onduplicate="ignore"/>
  </admst:for-each>
  <admst:reverse select="$noinames"/>

  <!--
    Find the current probes.
    We will deal with I(x,x) where x is a module port, otherwise the
    branch must be created by a V() <+ contribution.
  -->
  <admst:apply-templates select="analog/code" match="find:curprobes"/>

</admst:template>

</admst>

